#!/bin/sh
# shellcheck disable=SC2086

# screencast - POSIX-compliant shell script to record a X11 desktop
#
# Copyright (c) 2015-2017 Daniel Bermond < yahoo.com: danielbermond >
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#########################################
#           general settings            #
#########################################

# program settings
screencast_version='v1.4.0.next'
screencast_website='https://github.com/dbermond/screencast/'

# system related settings
savedir="$(pwd)"             # path to save output files
tmpdir='/tmp'                # path for temporary files
queue_size='3096'            # ffmpeg thread queue size
ffplay_volume='35'           # ffplay playback volume (0-100)
finish_sound='/usr/share/sounds/freedesktop/stereo/complete.oga'
finish_icon='/usr/share/icons/oxygen/base/128x128/actions/dialog-ok-apply.png'

# control settings (controls various aspects)
saving_output='true'         # if user is saving an output video (true, false)
recording_audio='true'       # if user is recording audio (true, false)
select_region='false'        # mouse screen region selection (true, false)
auto_filename='false'        # auto choose output filename based on date/time
keep_video='false'           # keep live streaming or the tmp video (true, false)
fade='none'                  # fade effect (in, out, both, none)
watermark='false'            # watermark effect (true, false)
pngoptimizer='none'          # png (watermark) optimizer (truepng, pingo, optipng, opt-png, none)
webcam_overlay='false'       # webcam overlay effect (true, false)
streaming='false'            # live streaming (true, false)
one_step='false'             # one step process (true, false)
fixed_length='0'             # fixed length video in seconds (0 disable)
notifications='true'         # desktop notifications (true, false)
audio_input_setted='false'   # if audio input    was setted by cmd line with -i
audio_encoder_setted='false' # if audio encoder  was setted by cmd line with -a
video_encoder_setted='false' # if video encoder  was setted by cmd line with -v
vaapi_device_setted='false'  # if a DRM node     was setted by cmd line with -A
video_size_setted='false'    # if video size     was setted by cmd line with -s
video_posi_setted='false'    # if video position was setted by cmd line with -p
video_rate_setted='false'    # if video rate/fps was setted by cmd line with -r
format_setted='false'        # if video format   was setted by cmd line with -f
fade_setted='false'          # if fade effect    was setted by cmd line with -e
volume_factor_setted='false' # if volume factor  was setted by cmd line with -m
wmark_size_setted='false'    # if wmark size     was setted by cmd line with -z
wmark_posi_setted='false'    # if wmark position was setted by cmd line with -k
wmark_font_setted='false'    # if wmark font     was setted by cmd line with -c
webcam_input_setted='false'  # if webcam input   was setted by cmd line with -I
webcam_size_setted='false'   # if webcam size    was setted by cmd line with -Z
webcam_posi_setted='false'   # if wcam position  was setted by cmd line with -P
webcam_rate_setted='false'   # if webcam fps     was setted by cmd line with -R
fixed_length_setted='false'  # if fixed length   was setted by cmd line with -x
pngoptimizer_setted='false'  # if png optimizer  was setted by cmd line with -g
outputdir_setted='false'     # if output dir     was setted by cmd line with -o

# audio settings
audio_input='default'        # audio input
audio_encoder='aac'          # audio encoder
volume_factor='1.0'          # volume increase effect factor (0.0/1.0 disable)
audio_channel_layout='-channel_layout stereo'
audio_input_options="-f alsa -thread_queue_size ${queue_size} -sample_rate 48000 -channels 2 ${audio_channel_layout}"

# video settings
video_encoder='x264'               # video encoder
pixel_format='yuv420p'             # pixel format
format='mp4'                       # container format (file extension) for output
video_position='0,0' #200,234      # X and Y screen coordinates to record video from
video_size='640x480'               # video size (resolution)
video_rate='25'                    # video framerate (fps)
corner_padding='10'                # video corner padding (for watermark and webcam effects)
vaapi_device='/dev/dri/renderD128' # DRM render node (vaapi device) (for vaapi video encoders)
video_input_options="-f x11grab -thread_queue_size ${queue_size} -probesize 20M -show_region 1 -region_border 2"

# metadata settings
metadata="comment=$(printf '%s\n%s' "Created with screencast ${screencast_version}" "${screencast_website}")"

# default options for later comparison (to print informative messages)
audio_encoder_default="$audio_encoder"
video_encoder_default="$video_encoder"
format_default="$format"

#########################################
#       container format settings       #
#########################################

# supported container formats (one per line for accurate grepping and easy deletion)
supported_formats_all="$(     printf 'mp4\nmov\nmkv\nwebm\nogg\nogv\nflv\nnut\nwmv\nasf\navi')"
supported_formats_lossless="$(printf 'matroska\nnut')"

# lossless container format settings functions: make checks and settings for container format to store lossless video
#                                               (for the 1st step, lossless recording)
# arguments: none
# return value: not relevant
# return code (status): 0 - the detected ffmpeg build has support for the tested container format
#                       1 - the detected ffmpeg build has no support for the tested container format
# sets special variable: $rec_extension - file extension (container format) of the lossless video
# note: the program will exit with error if the tested container format is not supported by the detected ffmpeg build
lossless_format_settings_matroska() {
    if check_component  matroska       muxer &&
       check_component 'matroska,webm' demuxer
    then
        rec_extension='mkv'
    else
        return 1
    fi
}

lossless_format_settings_nut() {
    if check_component nut muxer && 
       check_component nut demuxer
    then
        rec_extension='nut'
    else
        return 1
    fi
}

# format settings functions: make checks and settings for the selected container format
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variables: $supported_audiocodecs - audio encoders supported by the selected container format (one per line)
#                         $supported_videocodecs - video encoders supported by the selected container format (one per line)
# note: the program will exit with error if the selected container format is not supported by the detected ffmpeg build
format_settings_mp4() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d;/^wma$/d')"
    supported_videocodecs="$(printf '%s' "$supported_videocodecs_all" | sed '/^theora$/d;/^vp8$/d;/^vp8_vaapi$/d;/^wmv$/d')"
    
    # check if the detected ffmpeg build has support for the mp4/mov muxer
    check_component "$format" muxer || component_error "$format" muxer true
    
    # move the moov atom to the beginning of the file
    if [ "$streaming"  = 'true' ] 
    then
        faststart='[movflags=+faststart]'
    else
        faststart='-movflags +faststart'
    fi
}

format_settings_mov() {
    format_settings_mp4 "$@"
    
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d')"
    supported_videocodecs="$(printf '%s' "$supported_videocodecs_all" | sed '/^vp9$/d;/^vp9_vaapi$/d')"
    
    unplayable_audiocodecs_mov="$(printf 'vorbis\nwma')"
    unplayable_videocodecs_mov="$(printf 'theora\nvp8\nvp8_vaapi\nwmv')"
}

format_settings_mkv() {
    # note: mkv container formats supports all valid audio and video encoders for this program
    supported_audiocodecs="$supported_audiocodecs_all"
    supported_videocodecs="$supported_videocodecs_all"
    
    # check if the detected ffmpeg build has support for the matroska (mkv) muxer
    if [ "$rec_extension" != "$format" ] 
    then
        check_component matroska muxer || component_error matroska muxer true
    fi
}

format_settings_webm() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^aac$/d;/^mp3lame$/d;/^shine$/d;/^wma$/d')"
    supported_videocodecs="$(printf 'vp8\nvp8_vaapi\nvp9\nvp9_vaapi')"
    
    # check if the detected ffmpeg build has support for the webm muxer
    check_component "$format" muxer || component_error "$format" muxer true
    
    # auto choose audio/video encoder if needed
    [ "$audio_encoder_setted" = 'false' ] && audio_encoder='opus' && audio_outstr='(auto chosen)'
    [ "$video_encoder_setted" = 'false' ] && video_encoder='vp9'  && video_outstr='(auto chosen)'
}

format_settings_ogg() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^aac$/d;/^mp3lame$/d;/^shine$/d;/^wma$/d')"
    supported_videocodecs="$(printf 'vp8\nvp8_vaapi\ntheora')"
    
    # check if the detected ffmpeg build has support for the ogg/ogv muxer
    check_component "$format" muxer || component_error "$format" muxer true
    
    # auto choose audio/video encoder if needed
    [ "$audio_encoder_setted" = 'false' ] && audio_encoder='vorbis' && audio_outstr='(auto chosen)'
    [ "$video_encoder_setted" = 'false' ] && video_encoder='theora' && video_outstr='(auto chosen)'
}

format_settings_ogv() {
    format_settings_ogg "$@"
}

format_settings_flv() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d;/^vorbis$/d;/^wma$/d')"
    supported_videocodecs="$(printf 'x264\nh264_nvenc\nh264_vaapi\nh264_qsv')"
    
    # check if the detected ffmpeg build has support for the flv muxer only if recording offline
    # (flv muxer support in ffmpeg is already checked during the live streaming checks)
    if [ "$streaming" = 'false' ] 
    then
        check_component "$format" muxer || component_error "$format" muxer true
    fi
}

format_settings_nut() {
    # note: nut container formats supports all valid audio and video encoders for this program
    supported_audiocodecs="$supported_audiocodecs_all"
    supported_videocodecs="$supported_videocodecs_all"
    
    # check if the detected ffmpeg build has support for the nut muxer
    if [ "$rec_extension" != "$format" ] 
    then
        check_component "$format" muxer || component_error "$format" muxer true
    fi
}

format_settings_wmv() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d')"
    
    supported_videocodecs="$(printf '%s' "$supported_videocodecs_all" |
                                 sed '/^x265$/d;/^kvazaar$/d;/^hevc_nvenc$/d;/^hevc_vaapi$/d;/^hevc_qsv$/d')"
    
    # check if the detected ffmpeg build has support for the asf muxer
    # note: asf muxer is used for wmv (and wma) container format
    check_component asf muxer || component_error asf muxer true
}

format_settings_asf() {
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d')"
    
    supported_videocodecs="$(printf '%s' "$supported_videocodecs_all" |
                                 sed '/^x265$/d;/^kvazaar$/d;/^hevc_nvenc$/d;/^hevc_vaapi$/d;/^hevc_qsv$/d')"
    
    # check if the detected ffmpeg build has support for the asf muxer
    check_component "$format" muxer || component_error "$format" muxer true
}

format_settings_avi() {
    # note: avi container formats supports all valid video encoders for this program
    supported_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d')"
    supported_videocodecs="$supported_videocodecs_all"
    
    # check if the detected ffmpeg build has support for the avi muxer
    check_component "$format" muxer || component_error "$format" muxer true
}

#########################################
#         audio encoder settings        #
#########################################

# supported audio encoders (one per line for accurate grepping and easy deletion)
supported_audiocodecs_all="$(     printf 'aac\nopus\nvorbis\nmp3lame\nshine\nwma\nnone')"
supported_audiocodecs_lossless="$(printf 'pcm_s16le\nflac')"

# lossless audio encoder settings functions: make checks and settings for lossless audio encoder
#                                           (for the 1st step, lossless recording)
# arguments: none
# return value: not relevant
# return code (status): 0 - the detected ffmpeg build has support for the tested lossless audio_encoder
#                       1 - the detected ffmpeg build has no support for the tested lossless audio encoder
# sets special variable: $audio_record_codec - ffmpeg lossless audio codec option and settings
# note: the program will exit with error if the selected lossless audio encoder is not supported by the detected ffmpeg build
lossless_audiocodec_settings_pcm_s16le() {
    if check_component pcm_s16le encoder &&
       check_component pcm_s16le decoder
    then
        audio_record_codec='-codec:a pcm_s16le -ar 48000 -ac 2'
    else
        return 1
    fi
}

lossless_audiocodec_settings_flac() {
    if check_component flac encoder &&
       check_component flac decoder
    then
        audio_record_codec='-codec:a flac -b:a 320k -ar 48000 -ac 2'
    else
        return 1
    fi
}

# audio encoder settings functions: make checks and settings for the selected audio encoder
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variable: $audio_encode_codec - ffmpeg audio codec option and settings
# note: the program will exit with error if the selected audio encoder is not supported by the detected ffmpeg build
audiocodec_settings_aac() {
    if check_component libfdk_aac encoder
    then
        if [ "$streaming" = 'true' ] 
        then
            audio_encode_codec='-codec:a libfdk_aac -b:a  96k -ar 44100 -ac 2'
        else
            audio_encode_codec='-codec:a libfdk_aac -b:a 128k -ar 44100 -ac 2'
        fi
    else
        check_component aac encoder || component_error 'libfdk_aac or aac' 'audio encoder' true
        
        if [ "$streaming" = 'true' ] 
        then
            audio_encode_codec='-codec:a aac -b:a  96k -ar 44100 -ac 2'
        else
            audio_encode_codec='-codec:a aac -b:a 128k -ar 44100 -ac 2'
        fi
    fi
}

audiocodec_settings_vorbis() {
    check_component libvorbis encoder || component_error libvorbis 'audio encoder' true
    audio_encode_codec='-codec:a libvorbis -qscale:a 4 -ar 44100 -ac 2'
}

audiocodec_settings_opus() {
    check_component libopus encoder || component_error libopus 'audio encoder' true
    audio_encode_codec='-codec:a libopus -b:a 128k -ar 48000 -ac 2'
}

audiocodec_settings_mp3lame() {
    check_component libmp3lame encoder || component_error libmp3lame 'audio encoder' true
    
    if [ "$streaming" = 'true' ] 
    then
        audio_encode_codec='-codec:a libmp3lame -b:a  96k -ar 44100 -ac 2'
    else
        audio_encode_codec='-codec:a libmp3lame -b:a 128k -ar 44100 -ac 2'
    fi
}

audiocodec_settings_shine() {
    check_component libshine encoder || component_error libshine 'audio encoder' true
    
    if [ "$streaming" = 'true' ] 
    then
        audio_encode_codec='-codec:a libshine -b:a  96k -ar 44100 -ac 2'
    else
        audio_encode_codec='-codec:a libshine -b:a 128k -ar 44100 -ac 2'
    fi
}

audiocodec_settings_wma() {
    check_component wmav2 encoder || component_error wmav2 'audio encoder' true
    audio_encode_codec='-codec:a wmav2 -b:a 128k -ar 44100 -ac 2'
}

#########################################
#         video encoder settings        #
#########################################

# supported video encoders (one per line for accurate grepping and easy deletion)
supported_videocodecs_all="$(printf 'x264\nh264_nvenc\nh264_vaapi\nh264_qsv
                                     x265\nhevc_nvenc\nhevc_vaapi\nhevc_qsv\nkvazaar
                                     vp8\nvp8_vaapi
                                     vp9\nvp9_vaapi
                                     theora\nwmv' | sed 's/^[[:space:]]*//g')"

supported_videocodecs_software="$(printf 'x264\nx265\nkvazaar\nvp8\nvp9\n\ntheora\nwmv')"
supported_videocodecs_lossless="$(printf 'ffv1\nffvhuff\nhuffyuv')"
largefile_videocodecs_lossless="$(printf 'ffvhuff\nhuffyuv')"

# supported video encoders (for use with show_list() in -l/--list option)
get_list_videocodecs() {
    for item in $supported_videocodecs_all
    do
        list_videocodecs="${list_videocodecs:-}${item}, "
    done
    
    # shellcheck disable=SC1004
    list_videocodecs="$(printf '%s' "$list_videocodecs" | sed 's/,[[:space:]]$//;s/[[:space:]]x265.*/\
                        &/;s/[[:space:]]vp8.*/\
                        &/')"
}

# get_videocodecs_for_nonmulti8_msg function: defines video encoders to be used with dimension_msg()
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variables: $msg_speedloss_videocodecs   - video encoders that can lead to speedloss with non multiple of
#                                                        8 dimensions (one per line)
#                         $msg_requirement_videocodecs - video encoders requires multiple of 8 dimensions (one per line)
get_videocodecs_for_nonmulti8_msg() {
    msg_speedloss_videocodecs="$(printf '%s' "$supported_videocodecs_all" |
                                     sed '/^x265$/d;/^kvazaar$/d;/^hevc_nvenc$/d;/^hevc_vaapi$/d;/^hevc_qsv$/d')"
    
    msg_requirement_videocodecs="$(printf 'x265\nkvazaar\nhevc_nvenc\nhevc_vaapi\nhevc_qsv')"
}

# lossless video encoder settings functions: make checks and settings for lossless video encoder
#                                           (for the 1st step, lossless recording)
# arguments: none
# return value: not relevant
# return code (status): 0 - the detected ffmpeg build has support for the tested lossless video_encoder
#                       1 - the detected ffmpeg build has no support for the tested lossless video encoder
# sets special variable: $video_record_codec - ffmpeg lossless video codec option and settings
# note: the program will exit with error if the selected lossless video encoder is not supported by the detected ffmpeg build
lossless_videocodec_settings_ffv1() {
    if check_component ffv1 encoder &&
       check_component ffv1 decoder
    then
        video_record_codec='ffv1 -level 3 -slicecrc 1'
    else
        return 1
    fi
}

lossless_videocodec_settings_ffvhuff() {
    if check_component ffvhuff encoder &&
       check_component ffvhuff decoder
    then
        video_record_codec='ffvhuff'
    else
        return 1
    fi
}

lossless_videocodec_settings_huffyuv() {
    if check_component huffyuv encoder &&
       check_component huffyuv decoder
    then
        video_record_codec='huffyuv'
    else
        return 1
    fi
}

# video encoder settings functions: make checks and settings for the selected video encoder
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variable: $video_encode_codec - ffmpeg video codec settings
# note: the program will exit with error if the selected video encoder is not supported by the detected ffmpeg build
videocodec_settings_x264() {
    check_component libx264 encoder || component_error libx264 'video encoder' true
    
    if [ "$streaming" = 'true' ] 
    then
        video_encode_codec='libx264 -crf 30 -preset veryfast'
    else
        if [ "$one_step" = 'false' ] 
        then
            video_encode_codec='libx264 -crf 21 -preset veryslow'
        else
            video_encode_codec='libx264 -crf 21 -preset ultrafast'
        fi
    fi
}

videocodec_settings_h264_nvenc() {
    check_component h264_nvenc encoder || component_error h264_nvenc 'video encoder' true
    video_encode_codec='h264_nvenc -qmin 10 -qmax 42 -preset slow -cq 10 -bf 2 -g 150'
}

videocodec_settings_h264_vaapi() {
    check_component h264_vaapi encoder || component_error h264_vaapi 'video encoder' true
    check_vaapi_device
    video_encode_codec='h264_vaapi -qp 18'
}

videocodec_settings_h264_qsv() {
    check_component h264_qsv encoder || component_error h264_qsv 'video encoder' true
    video_encode_codec='h264_qsv -preset:v medium -rdo 1 -qscale:v 5 -look_ahead 0'
}

videocodec_settings_x265() {
    check_component libx265 encoder || component_error libx265 'video encoder' true
    
    if [ "$one_step" = 'false' ] 
    then
        video_encode_codec='libx265 -crf 25 -preset veryslow'
    else
        video_encode_codec='libx265 -crf 25 -preset ultrafast'
    fi
}

videocodec_settings_kvazaar() {
    check_component libkvazaar encoder || component_error libkvazaar 'video encoder' true
    
    if [ "$one_step" = 'false' ] 
    then
        video_encode_codec='libkvazaar -kvazaar-params preset=veryslow'
    else
        video_encode_codec='libkvazaar -kvazaar-params preset=ultrafast'
    fi
}

videocodec_settings_hevc_nvenc() {
    check_component hevc_nvenc encoder || component_error hevc_nvenc 'video encoder' true
    video_encode_codec='hevc_nvenc -preset slow'
}

videocodec_settings_hevc_vaapi() {
    check_component hevc_vaapi encoder || component_error hevc_vaapi 'video encoder' true
    check_vaapi_device
    video_encode_codec='hevc_vaapi -qp 22'
}

videocodec_settings_hevc_qsv() {
    check_component hevc_qsv encoder || component_error hevc_qsv 'video encoder' true
    video_encode_codec='hevc_qsv -load_plugin hevc_hw -preset:v medium -rdo 1 -qscale:v 5 -look_ahead 0'
}

videocodec_settings_vp8() {
    check_component libvpx encoder || component_error libvpx 'video encoder' true
    video_record_codec="${video_record_codec} -pix_fmt yuv420p"
    video_encode_codec='libvpx -crf 8 -b:v 2M'
}

videocodec_settings_vp8_vaapi() {
    check_component vp8_vaapi encoder || component_error vp8_vaapi 'video encoder' true
    check_vaapi_device
    video_encode_codec='vp8_vaapi -global_quality 30'
}

videocodec_settings_vp9() {
    check_component libvpx-vp9 encoder || component_error libvpx-vp9 'video encoder' true
    video_encode_codec='libvpx-vp9 -crf 30 -b:v 0'
}

videocodec_settings_vp9_vaapi() {
    check_component vp9_vaapi encoder || component_error vp9_vaapi 'video encoder' true
    check_vaapi_device
    video_encode_codec='vp9_vaapi -global_quality 80'
}

videocodec_settings_theora() {
    check_component libtheora encoder || component_error libtheora 'video encoder' true
    video_encode_codec='libtheora -qscale:v 5'
}

videocodec_settings_wmv() {
    check_component wmv2 encoder || component_error wmv2 'video encoder' true
    video_encode_codec='wmv2 -qscale:v 3'
}

#########################################
#            effects settings           #
#########################################

# watermark settings
watermark_font='Arial'
watermark_size='255x35'
watermark_position='bottomright'
    # good absolute position values for hd720p (1280x720) with default watermark size:
    # 970,10  - top right corner
    # 10,10   - top left  corner
    # 970,688 - bottom right corner
    # 10,688  - bottom left  corner
    # 550,350 - centralized

# webcam settings
webcam_input_options="-f video4linux2 -thread_queue_size ${queue_size} -probesize 10M"
webcam_size='320x240'
webcam_input='/dev/video0'
webcam_position='topright'

# effect settings functions: make settings for the selected effect(s)
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variables: various, depending on the effect
get_supported_fade() {
    supported_fade="$(printf 'none\nin\nout\nboth')"
}

get_supported_pngoptmz() {
    supported_pngoptmz="$(printf 'none\noptipng\nopt-png\ntruepng\npingo')"
}

get_fade_settings() {
    fade_color='black'      # color to be used by the video fade effect
    fade_length='0.6'       # length (in seconds) of video fade effect itself
    fade_solid_length='0.1' # solid color length (in seconds) of video fade effect
}

get_supported_streaming_settings() {
    # supported audio/video encoders in the flv muxer that have restrictions in specific container formats
    supported_streaming_formats="$(printf '%s' "$supported_formats_all" | sed '/^ogg$/d;/^ogv$/d;/^webm$/d')"
    
    # flv muxer restrictions
    supported_streaming_audiocodecs="$(printf '%s' "$supported_audiocodecs_all" | sed '/^opus$/d;/^vorbis$/d;/^wma$/d')"
    supported_streaming_videocodecs="$(printf 'x264\nh264_nvenc\nh264_vaapi\nh264_qsv\n')"
}

get_pngoptmz_settings_truepng() {
    pngoptmz_settings='-o max'
}

get_pngoptmz_settings_pingo() {
    pngoptmz_settings='-s8'
}

get_pngoptmz_settings_optipng() {
    pngoptmz_settings='-o 7'
}

get_pngoptmz_settings_advdef() {
    advdef_settings='-z4i10'
}

#########################################
#           general functions           #
#########################################

# cleanup function: delete unneeded files
# arguments: none
# return value: none
# return code (status): not relevant
cleanup() {
    # delete temporary files
    rm -f "${tmpdir}/screencast-tmpimage-${$}-${rndstr_png}.png"
    [ "$keep_video" = 'false' ] && rm -f "${tmpdir}/screencast-tmpvideo-${$}-${rndstr_video}.${rec_extension}"
    
    # delete zero-sized output file in case some unexpected error occurred
    if [ -f "${savedir}/${output_file}" ] 
    then
        output_filesize="$(du -k "${savedir}/${output_file}" | cut -f1)"
        [ "$output_filesize" -eq '0' ] && rm -f "${savedir}/${output_file}"
    fi
}

# print_good, print_info, print_warn and print_error functions:
# print a formated message with colors if avaiable, otherwise it will fallback
# to non-color output (note: print_error() prints to stderr by default)
# arguments: $1 - message to print
# return value: the message to print
# return code (status): not relevant
print_good() {
    printf '%s\n' "${msg_header}${color_off:-} ${1}"
}

print_info() {
    printf '%s\n' "${msg_header}${color_bold:-} info:${color_off:-} ${1}"
}

print_warn() {
    printf '%s\n' "${msg_header}${color_yellow:-} warning:${color_off:-} ${1}"
}

print_error() {
    printf '%s\n' "${msg_header}${color_red:-} error:${color_off:-} ${1}" >&2
}

# show_header function: show program header
# arguments: $1 - the positional parameters passed with double quotes ("$@")
# return value: the program header
# return code (status): not relevant
show_header() {
    # give error if --version/-V is not the unique command line option
    if [ "$shift_count" -ne '0' ] || [ "$#" -ne '1' ] 
    then
        exit_program "--version (-V) option can be used only alone"
    fi
    
    printf '%s\n' "screencast ${screencast_version} - Command line interface to record a X11 desktop"
    printf '%s\n' "Copyright (c) 2015-$(date +%Y) Daniel Bermond"
    printf '%s\n' "$screencast_website"
}

# help function
# arguments: $1 - the positional parameters passed with double quotes ("$@")
# return value: the program help screen
# return code (status): not relevant
show_help() {
    # give error if --help/-h/-? is not the unique command line option
    if [ "$shift_count" -ne '0' ] || [ "$#" -ne '1' ] 
    then
        exit_program "--help (-h) option can be used only alone"
    fi
    
    show_header "$@"
    
    printf '\n'
    printf '%s\n' 'Usage: screencast [options] <output>'
    printf '%s\n' '                  [options] -u'
    printf '\n'
    printf 'Options:\n'
    printf '%s\n' "  -s, --size=NxN            video size (resolution) [${video_size}]"
    printf '%s\n' "  -p, --position=N,N        recording position (screen XY topleft offsets) [${video_position}]"
    printf '%s\n' '  -S, --select-region       select with mouse the screen region to record'
    printf '%s\n' "  -r, --fps=N               video framerate (fps) [${video_rate}]"
    printf '%s\n' "  -f, --format=TYPE         container format (to use with -u) [${format}]"
    printf '%s\n' "  -i, --audio-input=NAME    audio input device [${audio_input}]"
    printf '%s\n' "  -a, --audio-encoder=NAME  audio encoder [${audio_encoder}]"
    printf '%s\n' "  -v, --video-encoder=NAME  video encoder [${video_encoder}]"
    printf '%s\n' "  -A, --vaapi-device=NODE   DRM render node [${vaapi_device}]"
    printf '%s\n' "  -e, --fade=TYPE           video fade effect [${fade}]"
    printf '%s\n' "  -m, --volume-factor=N     volume increase effect factor (1.0 disable) [${volume_factor}]"
    printf '%s\n' '  -w, --watermark=TEXT      enable and set text watermark effect [disabled]'
    printf '%s\n' "  -z, --wmark-size=NxN      watermark image size (resolution) [${watermark_size}]"
    printf '%s\n' '  -k, --wmark-position=N,N  watermark position (video XY topleft offsets,'
    printf '%s\n' "      --wmark-position=PRE    or a predefined special value) [${watermark_position}]"
    printf '%s\n' "  -c, --wmark-font=NAME     watermark font [${watermark_font}]"
    printf '%s\n' '  -W, --webcam              enable webcam overlay effect [disabled]'
    printf '%s\n' "  -I, --webcam-input=DEV    webcam input device [${webcam_input}]"
    printf '%s\n' "  -Z, --webcam-size=NxN     webcam video size (resolution) [${webcam_size}]"
    printf '%s\n' '  -P, --webcam-position=N,N webcam position (video XY topleft offsets,'
    printf '%s\n' "      --webcam-position=PRE   or a predefined special value) [${webcam_position}]"
    printf '%s\n' '  -R, --webcam-fps=N        webcam framerate (fps) [device default]'
    printf '%s\n' '  -L, --live-streaming=URL  enable live streaming, setting url to URL [disabled]'
    printf '%s\n' '  -1, --one-step            one step (record and encode at same time) [disabled]'
    printf '%s\n' "  -x, --fixed=N             fixed video length for N seconds (0 disable) [${fixed_length}]"
    printf '%s\n' '  -n, --no-notifications    disable desktop notifications'
    printf '%s\n' "  -g, --png-optimizer=NAME  use png (watermark) optimizer and advdef [${pngoptimizer}]"
    printf '%s\n' '  -o, --output-dir=DIR      save videos to DIR (to use with -u) [local dir]'
    printf '%s\n' "  -t, --tmp-dir=DIR         use DIR for temporary files [${tmpdir}]"
    printf '%s\n' '  -K, --keep                keep the temporary video or the live streaming'
    printf '%s\n' '  -u, --auto-filename       auto choose output filename based on date/time'
    printf '%s\n' '  -l, --list                list arguments supported by these options'
    printf '%s\n' '  -h, --help                this help screen'
    printf '%s\n' '  -V, --version             version information'
    printf '\n'
    printf '%s\n' "For further help run 'man screencast'"
}

# notify function: show a desktop notification if setted to do so
# arguments: $1 - urgency level (low, normal, critial)
#            $2 - duration in milliseconds
#            $3 - icon name
#            $4 - text message
# return value: none
# return code (status): not relevant
notify() {
    notify_args="--urgency=${1} --expire-time=${2} --icon=${3}"
    [ "$notifications" = 'true' ] && notify-send $notify_args screencast "$(remove_spaces "$4")"
}

# check_requirements function: check if required programs are installed
# arguments: none
# return value: not relevant
# return code (status): not relevant
check_requirements() {
    # note: although bc is defined by POSIX, some GNU/Linux distributions
    #       does not include it by default (e.g.: Arch Linux)
    for requirement in notify-send  ffmpeg   xdpyinfo  slop             ffprobe \
                       bc           convert  magick    "$pngoptimizer"  advdef
    do
        # skip disabled components (unnecessary checks)
        if {
               [ "$requirement"   = 'slop'  ] &&
               [ "$select_region" = 'false' ] ;
           } ||
           {
               {
                   [ "$requirement" = 'ffprobe' ] ||
                   [ "$requirement" = 'bc'      ] ;
               } &&
               [ "$fade" = 'none'  ] ;
           } ||
           {
               {
                   [ "$requirement" = 'convert' ] ||
                   [ "$requirement" = 'magick'  ] ;
               } &&
               [ "$watermark" = 'false'  ] ;
           } ||
           {
               [ "$requirement"  = "$pngoptimizer" ] &&
               [ "$pngoptimizer" = 'none'          ] ;
           } ||
           {
               [ "$requirement"  = 'advdef' ] &&
               [ "$pngoptimizer" = "none"   ] ;
           } ||
           {
               [ "$requirement"   = 'notify-send' ] &&
               [ "$notifications" = 'false'       ] ;
           }
        then
            continue
        fi
        
        case "$requirement" in
            notify-send)
                unset request_string
                installname="${requirement} (libnotify) (or use '-n')"
                ;;
            ffmpeg)
                unset request_string
                installname='ffmpeg (version git master preferred)'
                ;;
            ffprobe)
                request_string='video fade effect was requested but '
                installname='ffprobe (ffmpeg) (version git master preferred)'
                ;;
            bc)
                request_string='video fade effect was requested but '
                installname="$requirement"
                ;;
            convert|magick)
                request_string='text watermark was requested but '
                installname='ImageMagick (IM7 preferred)'
                ;;
            slop)
                request_string='screen region selection was requested but '
                installname="$requirement"
                ;;
            "$pngoptimizer")
                request_string='png optimization was requested but '
                installname="$requirement"
                ;;
            advdef)
                request_string='png optimization was requested but '
                installname="${requirement} (advancecomp)"
                ;;
            *)
                unset request_string
                installname="$requirement"
                ;;
        esac
        
        if ! command -v "$requirement" >/dev/null 2>&1
        then
            if [ "$requirement"  = 'magick' ] 
            then
                # in this case IM6 was found because 'convert' goes first
                magick() {
                    convert "$@"
                }
                continue
            else
                msg="${request_string:-}'${requirement}' was not found"
                print_error "$msg"
                printf '%s%s\n' '                      ' \
                          "please install ${installname}" >&2
                [ "$requirement" != 'notify-send' ] &&
                    notify 'critical' '5000' 'dialog-error' "$msg"
                exit 1
            fi
        fi
    done
}

# command_error function: print an error message regarding invalid command
#                         line arguments, show notification and exit with error
# arguments: $1 - command line option name (e.g.: "--fade (-e)")
# return value: not relevant
# return code (status): not relevant
command_error() {
    msg='option requires an argument'
    print_error "${1} ${msg}"
    notify 'critical' '5000' 'dialog-error' "error: ${1} ${msg}"
    exit 1
}

# exit_program: print an error message to stderr, a desktop notification
#               (if it is enabled) and exit with error
# arguments: $1 - error message to print/notificate
# return value: not relevant
# return code (status): not relevant
exit_program() {
    print_error "${1}"
    notify 'critical' '5000' 'dialog-error' "error: ${1}"
    exit 1
}

# remove_spaces function: remove two or more consecutive spaces from a string,
#                         making them to be a single space
# arguments: $1 - the string to modify
# return value: a modified string
# return code (status): not relevant
remove_spaces() {
    printf '%s' "$1" | sed 's/[[:space:]]\{1,\}/ /g'
}

# show_list function: print a list of arguments supported by this program
# arguments: $1 - the positional parameters passed with double quotes ("$@")
# return value: the described list
# return code (status): not relevant
show_list() {
    # give error if --list/-l is not the unique command line option
    if [ "$shift_count" -ne '0' ] || [ "$#" -ne '1' ] 
    then
        exit_program "--list (-l) option can be used only alone"
    fi
    
    show_header "$@"
    get_list_videocodecs
    get_supported_fade
    get_supported_pngoptmz
    
    for item in $supported_formats_all
    do
        list_formats="${list_formats:-}${item}, "
    done
    
    for item in $supported_audiocodecs_all
    do
        list_audiocodecs="${list_audiocodecs:-}${item}, "
    done
    
    for item in $supported_fade
    do
        list_fade="${list_fade:-}${item}, "
    done
    
    for item in $supported_pngoptmz
    do
        list_pngoptmz="${list_pngoptmz:-}${item}, "
    done
    
    list_audiocodecs="$(printf '%s' "$list_audiocodecs" | sed 's/,[[:space:]]$//')"
    list_formats="$(    printf '%s' "$list_formats"     | sed 's/,[[:space:]]$//')"
    list_fade="$(       printf '%s' "$list_fade"        | sed 's/,[[:space:]]$//')"
    list_pngoptmz="$(   printf '%s' "$list_pngoptmz"    | sed 's/,[[:space:]]$//')"
    
    list_wmark_position='topleft, topright, bottomleft, bottomright
                         (or the respective aliases tl, tr, bl, br)'
                         
    list_webcam_position="$list_wmark_position"
    
    printf '\n'
    printf '%s\n' 'Supported arguments:'
    printf '%s\n' "  -f, --format           $(printf '%s' "$list_formats")"
    printf '\n'
    printf '%s\n' "  -a, --audio-encoder    $(printf '%s' "$list_audiocodecs")"
    printf '\n'
    printf '%s\n' "  -v, --video-encoder    $(printf '%s' "$list_videocodecs")"
    printf '\n'
    printf '%s\n' "  -e, --fade             $(printf '%s' "$list_fade")"
    printf '\n'
    printf '%s\n' "  -k, --wmark-position   $(printf '%s' "$list_wmark_position")"
    printf '\n'
    printf '%s\n' "  -P, --webcam-position  $(printf '%s' "$list_webcam_position")"
    printf '\n'
    printf '%s\n' "  -g, --png-optimizer    $(printf '%s' "$list_pngoptmz")"
    printf '\n'
    printf '%s\n' '  note: selecting vorbis or opus audio encoders actually uses the higher'
    printf '%s\n' '        quality libvorbis and libopus encoders respectively.'
    printf '\n'
    printf '%s\n' '  note: the container formats mkv and nut support a combination of all audio'
    printf '%s\n' '        and video encoders. Restrictions apply to other container formats.'
}

# get_cmd_line function: get command line arguments and adjust related variables
# arguments: $1 - the positional parameters passed with double quotes ("$@")
# return value: none
# return code (status): not relevant
# sets special variables: $shift_count - how many shifts were executed
get_cmd_line() {
    shift_count='0' # counts how many 'shift' commands were executed
    
    while :
    do
        # since this is a very long case statement only the first block will
        # be commented. almost all other blocks follows the same sequence/logic
        # and comments will be inserted only for what is different.
        case "$1" in
            # short option and long option without '='
            -s|--size)
                # search for an argument
                if [ -n "$2" ] 
                then
                    # errors out if no argument was entered after the option
                    # (will check for a leading '-' in the next parameter,
                    #  meaning that another option was found)
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--size (-s)'
                    else
                        video_size="$2"
                        video_size_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                # errors out if no argument is found
                else
                    command_error '--size (-s)'
                fi
                ;;
            # long option with '='
            --size=?*)
                video_size="${1#*=}" # assign value after '='
                video_size_setted='true'
                ;;
            # errors out if a long option with '=' has nothing following '='
            --size=)
                command_error '--size (-s)'
                ;;
            
            -p|--position)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--position (-p)'
                    else
                        video_position="$2"
                        video_posi_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--position (-p)'
                fi
                ;;
            --position=?*)
                video_position="${1#*=}"
                video_posi_setted='true'
                ;;
            --position=)
                command_error '--position (-p)'
                ;;
            
            -S|--select-region) # option without argument
                select_region='true'
                ;;
            
            -r|--fps)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fps (-r)'
                    else
                        video_rate="$2"
                        video_rate_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fps (-r)'
                fi
                ;;
            --fps=?*)
                video_rate="${1#*=}"
                video_rate_setted='true'
                ;;
            --fps=)
                command_error '--fps (-r)'
                ;;
            
            -f|--format)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--format (-f)'
                    else
                        format="$2"
                        format_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--format (-f)'
                fi
                ;;
            --format=?*)
                format="${1#*=}"
                format_setted='true'
                ;;
            --format=)
                command_error '--format (-f)'
                ;;
            
            -i|--audio-input)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--audio-input (-i)'
                    else
                        audio_input="${2}"
                        audio_input_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--audio-input (-i)'
                fi
                ;;
            --audio-input=?*)
                audio_input="${1#*=}"
                audio_input_setted='true'
                ;;
            --audio-input=)
                command_error '--audio-input (-i)'
                ;;
            
            -a|--audio-encoder)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--audio-encoder (-a)'
                    else
                        audio_encoder="$2"
                        audio_encoder_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--audio-encoder (-a)'
                fi
                ;;
            --audio-encoder=?*)
                audio_encoder="${1#*=}"
                audio_encoder_setted='true'
                ;;
            --audio-encoder=)
                command_error '--audio-encoder (-a)'
                ;;
            
            -v|--video-encoder)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--video-encoder (-v)'
                    else
                        video_encoder="$2"
                        video_encoder_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--video-encoder (-v)'
                fi
                ;;
            --video-encoder=?*)
                video_encoder="${1#*=}"
                video_encoder_setted='true'
                ;;
            --video-encoder=)
                command_error '--video-encoder (-v)'
                ;;
            
            -A|--vaapi-device)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--vaapi-device (-A)'
                    else
                        vaapi_device="$2"
                        vaapi_device_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--vaapi-device (-A)'
                fi
                ;;
            --vaapi-device=?*)
                vaapi_device="$2"
                vaapi_device_setted='true'
                ;;
            --vaapi-device=)
                command_error '--vaapi-device (-A)'
                ;;
            
            -e|--fade)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fade (-e)'
                    else
                        fade="$2"
                        fade_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fade (-e)'
                fi
                ;;
            --fade=?*)
                fade="${1#*=}"
                fade_setted='true'
                ;;
            --fade=)
                command_error '--fade (-e)'
                ;;
            
            -m|--volume-factor)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--volume-factor (-u)'
                    else
                        volume_factor="$2"
                        volume_factor_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--volume-factor (-m)'
                fi
                ;;
            --volume-factor=?*)
                volume_factor="${1#*=}"
                volume_factor_setted='true'
                ;;
            --volume-factor=)
                command_error '--volume-factor (-m)'
                ;;
            
            -w|--watermark)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--watermark (-w)'
                    else
                        watermark_text="$2"
                        watermark='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--watermark (-w)'
                fi
                ;;
            --watermark=?*)
                watermark_text="${1#*=}"
                watermark='true'
                ;;
            --watermark=)
                command_error '--watermark (-w)'
                ;;
            
            -z|--wmark-size)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-size (-z)'
                    else
                        watermark_size="$2"
                        wmark_size_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-size (-z)'
                fi
                ;;
            --wmark-size=?*)
                watermark_size="${1#*=}"
                wmark_size_setted='true'
                ;;
            --wmark-size=)
                command_error '--wmark-size (-z)'
                ;;
            
            -k|--wmark-position)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-position (-k)'
                    else
                        watermark_position="$2"
                        wmark_posi_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-position (-k)'
                fi
                ;;
            --wmark-position=?*)
                watermark_position="${1#*=}"
                wmark_posi_setted='true'
                ;;
            --wmark-position=)
                command_error '--wmark-position (-k)'
                ;;
            
            -c|--wmark-font)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-font (-c)'
                    else
                        watermark_font="$2"
                        wmark_font_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-font (-c)'
                fi
                ;;
            --wmark-font=?*)
                watermark_font="${1#*=}"
                wmark_font_setted='true'
                ;;
            --wmark-font=)
                command_error '--wmark-font (-c)'
                ;;
            
            -W|--webcam) # option without argument
                webcam_overlay='true'
                ;;
            
            -I|--webcam-input)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--webcam-input (-I)'
                    else
                        webcam_input="${2}"
                        webcam_input_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--webcam-input (-I)'
                fi
                ;;
            --webcam-input=?*)
                webcam_input="${1#*=}"
                webcam_input_setted='true'
                ;;
            --audio-input=)
                command_error '--webcam-input (-I)'
                ;;
            
            -Z|--webcam-size)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--webcam-size (-Z)'
                    else
                        webcam_size="$2"
                        webcam_size_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--webcam-size (-Z)'
                fi
                ;;
            --webcam-size=?*)
                webcam_size="${1#*=}"
                webcam_size_setted='true'
                ;;
            --webcam-size=)
                command_error '--webcam-size (-Z)'
                ;;
            
            -P|--webcam-position)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--webcam-position (-P)'
                    else
                        webcam_position="$2"
                        webcam_posi_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--webcam-position (-P)'
                fi
                ;;
            --webcam-position=?*)
                webcam_position="${1#*=}"
                webcam_posi_setted='true'
                ;;
            --webcam-position=)
                command_error '--webcam-position (-P)'
                ;;
            
            -R|--webcam-fps)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--webcam-fps (-R)'
                    else
                        webcam_rate="$2"
                        webcam_rate_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--webcam-fps (-R)'
                fi
                ;;
            --webcam-position=?*)
                webcam_rate="${1#*=}"
                webcam_rate_setted='true'
                ;;
            --webcam-position=)
                command_error '--webcam-fps (-R)'
                ;;
            
            -L|--live-streaming)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--live-streaming (-L)'
                    else
                        streaming_url="$2"
                        streaming='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--live-streaming (-L)'
                fi
                ;;
            --live-streaming=?*)
                streaming_url="${1#*=}"
                streaming='true'
                ;;
            --live-streaming=)
                command_error '--live-streaming (-L)'
                ;;
            
            -x|--fixed)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fixed (-x)'
                    else
                        fixed_length="$2"
                        fixed_length_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fixed (-x)'
                fi
                ;;
            --fixed=?*)
                fixed_length="${1#*=}"
                fixed_length_setted='true'
                ;;
            --fixed=)
                command_error '--fixed (-x)'
                ;;
            
            -1|--one-step)  # option without argument
                one_step='true'
                ;;
            
            -n|--no-notifications)  # option without argument
                notifications='false'
                ;;
            
            -g|--png-optimizer)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--png-optimizer (-g)'
                    else
                        pngoptimizer="$2"
                        pngoptimizer_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--png-optimizer (-g)'
                fi
                ;;
            --png-optimizer=?*)
                pngoptimizer="${1#*=}"
                pngoptimizer_setted='true'
                ;;
            --png-optimizer=)
                command_error '--png-optimizer (-g)'
                ;;
            
            -o|--output-dir)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--output-dir (-o)'
                    else
                        savedir="${2%/}" # remove ending '/' if present
                        outputdir_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--output-dir (-o)'
                fi
                ;;
            --output-dir=?*)
                savedir="${1#*=}"
                savedir="${savedir%/}" # remove ending '/' if present
                outputdir_setted='true'
                ;;
            --output-dir=)
                command_error '--output-dir (-o)'
                ;;
            
            -t|--tmp-dir)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--tmp-dir (-t)'
                    else
                        tmpdir="${2%/}" # remove ending '/' if present
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--tmp-dir (-t)'
                fi
                ;;
            --tmp-dir=?*)
                tmpdir="${1#*=}"
                tmpdir="${tmpdir%/}" # remove ending '/' if present
                ;;
            --tmp-dir=)
                command_error '--tmp-dir (-t)'
                ;;
            
            -K|--keep) # option without argument
                keep_video='true'
                ;;
            
            -u|--auto-filename) # option without argument
                auto_filename='true'
                ;;
            
            -l|--list)  # option without argument
                show_list "$@"
                exit 0
                ;;
            
            -h|-\?|--help)  # option without argument
                show_help "$@"
                exit 0
                ;;
            
            -V|--version)  # option without argument
                show_header "$@"
                exit 0
                ;;
            
            --)   # check for the end of options marker '--'
                shift && shift_count="$((shift_count + 1))"
                break
                ;;
            
            -?*=?*) # unknown option with '=', handle argument also with '='
                exit_program "unknown option '${1%%=*}'"
                ;;
            
            -?*=) # unknown option with '='
                exit_program "unknown option '${1%=*}'"
                ;;
            
            -?*)
                exit_program "unknown option '${1}'"
                ;;
            
            *)    # no more options left
                break
        esac
        shift && shift_count="$((shift_count + 1))"
    done
}

# show_settings function: show information about some program settings
# arguments: none
# return value: program settings information
# return code (status): not relevant
show_settings() {
    [ "$video_encoder" = "$video_encoder_default" ] && [ "$video_encoder_setted" = 'false' ] && video_outstr='(default)'
    [ "$audio_encoder" = "$audio_encoder_default" ] && [ "$audio_encoder_setted" = 'false' ] && audio_outstr='(default)'
    [ "$format"        = "$format_default"        ] && [ "$format_setted"        = 'false' ] &&
        [ "$auto_filename" = 'true'  ] && format_outstr='(default)'
    
    case "$video_encoder" in
        *_vaapi)
            video_outstr="(${vaapi_device})"
            ;;
    esac
    
    [ "$fade" != 'none' ] && effects="fade-${fade}"
    if [ "$watermark" = 'true' ] 
    then
        effects="${effects:+"${effects}, watermark"}"
        effects="${effects:-watermark}"
    fi
    if [ "$webcam_overlay" = 'true' ] 
    then
        effects="${effects:+"${effects}, webcam overlay"}"
        effects="${effects:-webcam overlay}"
    fi
    if [ -n "$volume_options" ] 
    then
        effects="${effects:+"${effects}, volume (${volume_factor})"}"
        effects="${effects:-"volume (${volume_factor})"}"
    fi
    
    effects="${effects:-none}"
    
    print_good "${color_bold:-}video encoder   :${color_off:-} ${video_encoder} ${video_outstr:-}"
    print_good "${color_bold:-}audio encoder   :${color_off:-} ${audio_encoder} ${audio_outstr:-}"
    
    [ "$saving_output" = 'true' ] && print_good "${color_bold:-}container format:${color_off:-} ${format} ${format_outstr:-}"
    
    print_good "${color_bold:-}effects         :${color_off:-} ${effects}"
    
    # print a waning if user chosen a possible unplayable combinantion of encoder and container format
    if [ "$format" = 'mov' ] 
    then
        msg="on 'mov' container format may not be playable"
        
        if printf '%s' "$unplayable_audiocodecs_mov" | grep -q "^${audio_encoder}$"
        then
            print_warn "'${audio_encoder}' audio encoder ${msg}"
        fi
        
        if printf '%s' "$unplayable_videocodecs_mov" | grep -q "^${video_encoder}$"
        then
            print_warn "'${video_encoder}' video encoder ${msg}"
        fi
        
        unset msg
    fi
}

# component_error function: print an error message and show an error notification
#                           about a not found ffmpeg component and exit the program
# arguments: $1 - the not found ffmpeg component
#            $2 - ffmpeg component type
#                 ([audio/video ]encoder, [audio/video ]decoder, muxer, demuxer)
#            $3 - show suggestion to try a different component (true, false)
# return value: not relevant
# return code (status): not relevant
component_error() {
    print_error "the detected ffmpeg build has no support for '${1}' ${2}"
    printf '%s%s\n'   '                      ' \
                      "please install a ffmpeg build with support for '${1}' ${2}" >&2
                      
    notify 'critical' '5000' 'dialog-error' \
           "error: the detected ffmpeg build has no support for '${1}' ${2}"
    
    if [ "$3" =  'true' ] && printf '%s' "$2" | grep -q '.*encoder$'
    then
        printf '%s%s\n'   '                      ' \
                          "(or try a different ${2})" >&2
                          
    elif [ "$3" =  'true' ] && printf '%s' "$2" | grep -q 'muxer'
    then
        printf '%s%s\n'   '                      ' \
                          "(or try a different ${2}/format)" >&2
    fi
    
    exit 1
}

# check_lossless_component: check if at least one supported lossless component of the given type is
#                           available in the detected ffmpeg build
# arguments: $1 - component type (format, audiocodec, videocodec)
# return value: none
# return code (status): not relevant
# note1: it will fallback to the next supported lossless component of the given type that is found
# note2: program will exit with error if no supported lossless components of the given type are available in ffmpeg
check_lossless_component() {
    case "$1" in
        format)
            component_list="$supported_formats_lossless"
            component_generic_name='muxer/demuxer'
            ;;
        audiocodec)
            component_list="$supported_audiocodecs_lossless"
            component_generic_name='audio encoder/decoder'
            ;;
        videocodec)
            component_list="$supported_videocodecs_lossless"
            component_generic_name='video encoder/decoder'
            ;;
        *)
            exit_program "check_lossless_component(): invalid component type '${1}'"
            ;;
    esac
    
    first_component="$( printf '%s' "$component_list" | head -n 1)"
    second_component="$(printf '%s' "$component_list" | sed  -n '2p')"
    last_component="$(  printf '%s' "$component_list" | tail -n 1)"
        
    for component in $component_list
    do
        if "lossless_${1}_settings_${component}"
        then
            if [ "$component" = "$first_component" ] 
            then
                break
            else
                if [ "$component" = "$second_component" ] 
                then
                    previous_components="$(printf '%s' "$previous_components" | sed "s/,[[:space:]]$//")"
                    
                elif [ "$component" = "$last_component" ] 
                then
                    previous_components="$(printf '%s' "$previous_components" | sed 's/,[[:space:]]$//')"
                    last_word="$(          printf '%s' "$previous_components" | awk '{print $NF}')"
                    previous_components="$(printf '%s' "$previous_components" | sed "s/,[[:space:]]${last_word}$/ or ${last_word}/")"
                fi
                
                print_warn "no '${previous_components}' ${component_generic_name} support in ffmpeg"
                print_warn "falling back to '${component}' ${component_generic_name} for lossless recording"
                
                if [ "$1" = 'videocodec' ] &&
                   printf '%s' "$largefile_videocodecs_lossless" | grep -q "^${component}$"
                then
                    print_warn "'${component}' encoder will produce an extra-large temporary video, change the tmp direcotry if needed"
                fi
                
                break
            fi
        else
            if [ "$component" = "$last_component" ] 
            then
                previous_components="$(printf '%s' "$previous_components" | sed "s/,[[:space:]]$/ or ${component}/")"
                component_error "$previous_components" "$component_generic_name" false
            else
                previous_components="${previous_components:-}${component}, "
                continue
            fi
        fi
    done
    
    unset previous_components
}

# check_component function: check if the detected ffmpeg build has support for a given component
# arguments: $1 - component name
# arguments: $2 - component type (encoder, decoder, muxer, demuxer)
# return value: not relevant
# reutrn code (status): 0 - ffmpeg build has support for the desired component
#                       1 - ffmpeg build has no support for the desired component
# note1: needs $ffmpeg_codecs for encoders and decoders - ffmpeg_codecs="$(ffmpeg -codecs -v quiet)"
# note2: needs $ffmpeg_formats for muxers and demuxers - ffmpeg_formats="$(ffmpeg -formats -v quiet)"
check_component() {
    case "$2" in
        encoder)
            if ! printf '%s' "$ffmpeg_codecs" | grep -q "(encoders:.*${1}" &&
               ! printf '%s' "$ffmpeg_codecs" | grep -q "^[[:space:]].E.\{4\}[[:space:]]${1}[[:space:]]"
            then
                return 1
            fi
            ;;
        decoder)
            if ! printf '%s' "$ffmpeg_codecs" | grep -q "(decoders:.*${1}" &&
               ! printf '%s' "$ffmpeg_codecs" | grep -q "^[[:space:]]D.\{5\}[[:space:]]${1}[[:space:]]"
            then
                return 1
            fi
            ;;
        muxer)
            if ! printf '%s' "$ffmpeg_formats" | grep -q "^[[:space:]].E[[:space:]]${1}[[:space:]]"
            then
                return 1
            fi
            ;;
        demuxer)
            if ! printf '%s' "$ffmpeg_formats" | grep -q "^[[:space:]]D.[[:space:]]${1}[[:space:]]"
            then
                return 1
            fi
            ;;
        *)
            exit_program "check_component(): invalid component type '${2}'"
            ;;
    esac
}

# dimension_msg function: create an error/warning message to use with
#                         a given inappropriate video dimension
# arguments: $1 - a string denoting the given dimension (width/height)
# return value: a string with the created message
# return code (status): not relevant
dimension_msg() {
    get_videocodecs_for_nonmulti8_msg
    
    if printf '%s' "$msg_speedloss_videocodecs" | grep -q "^${video_encoder}$"
    then
        msg='(this can lead to a speedloss)'
        
    elif printf '%s' "$msg_requirement_videocodecs" | grep -q "^${video_encoder}$"
    then
        msg="(${video_encoder} requirement)"
    fi
    
    case "$1" in
        width)
            printf '%s' "video width '${video_width}' is not a multiple of 8 ${msg}"
            ;;
        height)
            printf '%s' "video height '${video_height}' is not a multiple of 8 ${msg}"
            ;;
        # no need to exit since it's usually called from a subshell
        *)
            printf '%s' "dimension_msg(): invalid \$1 '${1}'"
            ;;
    esac
    
    unset msg
}

# check_dimension function: check if a given dimension is a multiple of 8
# arguments:  $1 - the given dimension (the actual variable value)
# return value: none
# return code (status): 0 - the dimension is a multiple of 8
#                       1 - the dimension is not a multiple of 8
check_dimension() {
    dimension_value="$1"
    
    # the dimension will be a multiple of 8 if the remainder is 0
    [ "$((dimension_value % 8))" = '0' ]
}

# adjust_dimension function: change a given dimension to the immediately higher
#                            number that is a multiple of 8
# arguments: $1 - a string denoting the given dimension (width/height)
# return value = not relevant
# return code (status): not relevant
adjust_dimension() {
    dimension="$1"
    
    # get the dimension value denoted by the string in $dimension
    case "$dimension" in
        width)
            dimension_value="$video_width"
            ;;
        height)
            dimension_value="$video_height"
            ;;
        *)
            exit_program "adjust_dimension(): invalid dimension '${dimension}'"
            ;;
    esac
    
    # obtain the next multiple of 8 number
    remainder="$((dimension_value % 8))"
    to_reach="$((8 - remainder))"
    new_dimension_value="$((dimension_value + to_reach))"
    
    print_warn "$(dimension_msg "$dimension") and was changed to '${new_dimension_value}'"
    
    # change the given dimension to the new value
    case "$dimension" in
        width)
            video_width="$new_dimension_value"
            ;;
        height)
            video_height="$new_dimension_value"
            ;;
    esac
}

# check_screen function: check for valid video size and position in relation to the current screen size
#                        (will exit with error if any problem is encountered)
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: needs $video_width, $video_position_x, $video_height and $video_position_y
check_screen() {
    screen_size="$(xdpyinfo | grep 'dimensions' | head -n1 | awk '{ print $2 }')"
    screen_width="$( printf '%s' "$screen_size" | cut -d'x' -f1)"
    screen_height="$(printf '%s' "$screen_size" | cut -d'x' -f2)"
    
    if [ "$((video_width + video_position_x))" -gt "$screen_width"  ] 
    then
        exit_program 'recording area is out of screen bounds
                      (video width + position X is greater than the current screen width)'
    fi
    
    if [ "$((video_height + video_position_y))" -gt "$screen_height" ] 
    then
        exit_program 'recording area is out of screen bounds
                      (video height + position Y is greater than the current screen height)'
    fi
}

# check_vaapi_device function: check if specified DRM render node (vaapi device) exists (-A/--vaapi-device)
# arguments: none
# return value: not relevant
# return code (status): 0 - a valid DRM render node (vaapi device) exists
# note: it will make the program exit with error if an invalid DRM render node (vaapi device) was selected
check_vaapi_device() {
    [ -c "$vaapi_device" ] || exit_program "'${vaapi_device}' is not a valid DRM render node (VAAPI device) on this system"
}

# check_special_position function: check for a valid special position string
# arguments: $1 - the string to check
# return value: not relevant
# return code (status): 0 - a valid special positon string was passed
#                       1 - an invalid special positon string was passed
# sets special variables: $special_position - the value to which the string translates
check_special_position() {
    case "$1" in
        topright|tr)
            special_position="main_w-overlay_w-${corner_padding}:${corner_padding}"
            ;;
        bottomright|br)
            special_position="main_w-overlay_w-${corner_padding}:main_h-overlay_h-${corner_padding}"
            ;;
        topleft|tl)
            special_position="${corner_padding}:${corner_padding}"
            ;;
        bottomleft|bl)
            special_position="${corner_padding}:main_h-overlay_h-${corner_padding}"
            ;;
        *)
            return 1
            ;;
    esac
}

# check_alsa_long_name function: check for a valid ALSA input device long name
# arguments: none
# return value: none
# return code (status): 0 - a valid ALSA input device long name was entered
#                       1 - an invalid ALSA input device long name was entered
# note: it will make the program exit with error user selects the 'null' input device
check_alsa_long_name() {
    arecord="$(arecord -L)"
    
    # check if user has entered allowed variations of long device name
    if ! printf '%s' "$arecord" | grep -q  "^${audio_input}$"  &&
       ! printf '%s' "$arecord" | grep -Eq "^${audio_input}:?" &&
       ! printf '%s' "$arecord" | grep -Eq "^${audio_input%:*}:(CARD=)?${audio_input#*:}"
    then
        return 1
    fi
}

# check_alsa_short_name function: check for a valid ALSA input device short name
# arguments: none
# return value: none
# return code (status): 0 - a valid ALSA input device short name was entered
#                       1 - an invalid ALSA input device short name was entered
check_alsa_short_name() {
    arecord="$(arecord -l)"
    
    # format: [plug]hw:card
    if printf '%s' "$audio_input" | grep -Eq '^(plug)?+hw:[0-9]+$'
    then
        alsa_card="$(printf '%s' "$audio_input" | sed 's/.*hw://')"
        
        if ! printf '%s' "$arecord" | grep -q "card[[:space:]]${alsa_card}:"
        then
            return 1
        fi
        
    # format: [plug]hw:card,device
    elif printf '%s' "$audio_input" | grep -Eq '^(plug)?+hw:[0-9],[0-9]+$'
    then
        alsa_card="$(  printf '%s' "$audio_input" | sed 's/.*hw://;s/,.*//')"
        alsa_device="$(printf '%s' "$audio_input" | sed 's/.*hw://;s/.*,//')"
        
        if ! printf '%s' "$arecord" | grep "card[[:space:]]${alsa_card}:" | grep -q "device[[:space:]]${alsa_device}:"
        then
            return 1
        fi
        
    # format: [plug]hw:card,device,subdevice
    elif printf '%s' "$audio_input" | grep -Eq '^(plug)?+hw:[0-9],[0-9]+,[0-9]+$'
    then
        alsa_card="$(     printf '%s' "$audio_input" | sed 's/.*hw://;s/,.*//')"
        alsa_device="$(   printf '%s' "$audio_input" | sed 's/.*hw://;s/[0-9]\{1,\},//;s/,.*//')"
        alsa_subdevice="$(printf '%s' "$audio_input" | sed 's/.*hw://;s/[0-9]\{1,\},//;s/.*,//')"
        
        if printf '%s' "$arecord" | grep "card[[:space:]]${alsa_card}:" | grep -q "device[[:space:]]${alsa_device}:"
        then
            # find line number of specified card and device
            card_line="$(printf '%s' "$arecord" | sed -n "/card[[:space:]]${alsa_card}:.*device[[:space:]]${alsa_device}:.*/=")"
            
            # find how many subdevices this card/device have
            # ($card_line + 1 to match Subdevices: 1/1, Subdevices: 2/2, ...)
            subdevices="$(printf '%s' "$arecord" | sed -n "$((card_line + 1))p" | sed 's@.*/@@')"
            
            [ "$subdevices" = '1' ] && subdevices='0' # no need to extend line range if there is only one subdevice
            
            # grep for subdevice number in specific line range after $card_line
            if ! printf '%s' "$arecord" | sed -n "$((card_line + 2)),$((card_line + 2 + subdevices))p" | grep -q "Subdevice[[:space:]]#${alsa_subdevice}:"
            then
                return 1
            fi
        else
            return 1
        fi
    else
        return 1
    fi
}

# check_pngoptimizer function: check for a valid png optimizer (-g/--png-optimizer)
#                              (will exit with error if an invalid png optimizer is chosen)
# arguments: none
# return value: not relevant
# return code (status): 0 - a valid png optimizer was selected
# note1: it will make the program exit with error if an invalid png optimizer was selected
# note2: this png optimizer check should be on check_cmd_line(), but it is implemented
#        as a separate function to allow it to be executed before check_requirements()
check_pngoptimizer() {
    if [ "$pngoptimizer_setted" = 'true' ] 
    then
        get_supported_pngoptmz
        
        if ! printf '%s' "$supported_pngoptmz" | grep -q "^${pngoptimizer}$"
        then
            exit_program "'${pngoptimizer}' is not a valid PNG optimizer for this program"
        fi
    fi
}

# check_cmd_line function: check validity of command line options and arguments (aslo set some variables)
#                          (will exit with error if any inconsistency is found)
# arguments: the remainder positional parameters passed with double quotes ("$@")
# return value: none
# return code (status): not relevant
check_cmd_line() {
    if [ "$select_region" = 'true' ] 
    then
        # do not allow to use -S/--select-region with -s/--size or -p/--position
        [ "$video_size_setted" = 'true' ] && exit_program '--select-region (-S) option cannot be used with --size (-s) option'
        [ "$video_posi_setted" = 'true' ] && exit_program '--select-region (-S) option cannot be used with --position (-p) option'
    else
        # preparations for check_dimension() and check_screen()
        video_position_x="$(printf '%s' "$video_position" | cut -d',' -f1)"
        video_position_y="$(printf '%s' "$video_position" | cut -d',' -f2)"
        video_width="$(     printf '%s' "$video_size"     | cut -d'x' -f1)"
        video_height="$(    printf '%s' "$video_size"     | cut -d'x' -f2)"
        
        if [ "$video_size_setted" = 'true' ] 
        then
            # check for a valid video size format (NxN) (-s/--size)
            printf '%s' "$video_size" | grep -Eq '^[0-9]+x[0-9]+$' || exit_program "'${video_size}' is not a valid video size format"
            
            # check if video width and height are a multiple of 8
            check_dimension "$video_width"  || exit_program "$(dimension_msg 'width')"
            check_dimension "$video_height" || exit_program "$(dimension_msg 'height')"
        fi
        
        if [ "$video_posi_setted" = 'true' ] 
        then
            # check for a valid screen position format to record (N,N) (-p/--position)
            printf '%s' "$video_position" | grep -Eq '^[0-9]+,[0-9]+$' || exit_program "'${video_position}' is not a valid screen position format"
        fi
        
        check_screen
    fi
    
    if [ "$video_rate_setted" = 'true' ] 
    then
        # check if the entered framerate (fps) is a valid integer number (-r/--fps)
        # (when live streaming, the video framerate (fps) cannot be a floating point number
        #  because it will be multiplied by two to obtain the gop value. This multiplication
        #  will be done using the shell simple aritmetic operator, which does not support floats.
        #  This will make bc to be required only when using fade effect.)
        if [ "$streaming" = 'true' ] 
        then
            if ! printf '%s' "$video_rate" | grep -Eq '^[0-9]+$'
            then
                if printf '%s' "$video_rate" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
                then
                    exit_program 'video framerate (fps) cannot be a floating point value when live streaming'
                else
                    exit_program "'${video_rate}' is not a valid video framerate (fps) format"
                fi
            fi
        
        # check if the entered framerate (fps) is a valid integer/float number (-r/--fps)
        else
            printf '%s' "$video_rate" | grep -Eq '^[0-9]+(\.[0-9]+)?$' ||
                exit_program "'${video_rate}' is not a valid video framerate (fps) format"
        fi
    fi
    
    # check if user entered a valid audio encoder
    if [ "$audio_encoder_setted" = 'true' ] 
    then
        if ! printf '%s' "$supported_audiocodecs_all" | grep -q "^${audio_encoder}$"
        then
            exit_program "'${audio_encoder}' is not a valid audio encoder for this program"
        fi
    fi
    
    # check if user entered a valid video encoder
    if [ "$video_encoder_setted" = 'true' ] 
    then
        if ! printf '%s' "$supported_videocodecs_all" | grep -q "^${video_encoder}$"
        then
            exit_program "'${video_encoder}' is not a valid video encoder for this program"
        fi
    fi
    
    # check if user is recording audio (if not, modify the corresponding control variable)
    if [ "$audio_input" = 'none' ] || [ "$audio_encoder" = 'none' ] 
    then
        recording_audio='false'
    fi
    
    # check if user is saving an output video (if not, modify the corresponding control variable)
    [ "$streaming"  = 'true' ] && [ "$keep_video" = 'false' ] && saving_output='false'
    
    # check if user entered a valid fade effect (-e/--fade)
    if [ "$fade_setted" = 'true' ] 
    then
        get_supported_fade
        
        if printf '%s' "$supported_fade" | grep -q "^${fade}$"
        then
            # do not allow to use fade effect when using a one step process (-1/--one-step)
            [ "$one_step"  = 'true' ] && [ "$fade" != 'none' ] && exit_program 'fade effect (-e) cannot be used when using a one step process (-1)'
        else
            exit_program "'${fade}' is not a valid fade effect for this program"
        fi
    fi
    
    # checks and settings based on usage of the '-u' option
    if [ "$auto_filename" = 'false' ] 
    then
        # check if user have not entered an output filename after the options (only if saving the output video)
        [ "$#" -eq '0' ] && [ "$saving_output" = 'true' ] && exit_program "you must enter an output filename with extension (or use '-u')"
        
        # do not allow to enter an output filename when not saving the live streaming
        [ "$#" -eq '1' ] && [ "$saving_output" = 'false' ] &&
            exit_program "output filename was specified but but not saving the live streaming ('-K' not set)"
        
        # do not allow to enter anything after the output filename
        [ "$#" -gt '1' ] && exit_program 'please do not enter anything after the output filename'
        
        # do not allow to use -f/--format when specifying an output filename
        if [ "$format_setted" = 'true' ] &&
           {
               [ "$streaming" = 'false' ] ||
               {
                   [ "$streaming"  = 'true'  ] &&
                   [ "$keep_video" = 'false' ] ;
               } ;
           }
        then
            exit_program "--format (-f) option can be used only with --auto-filename (-u)
                      (when not using '-u', set format in the output filename)"
        fi
        
        # do not allow to use -o/--output-dir when specifying an output filename
        if [ "$outputdir_setted" = 'true' ] &&
           {
               [ "$streaming" = 'false' ] ||
               {
                   [ "$streaming"  = 'true'  ] &&
                   [ "$keep_video" = 'false' ] ;
               } ;
           }
        then
            exit_program "--output-dir (-o) option can be used only with --auto-filename (-u)
                      (when not using '-u', set output directory with the output filename)"
        fi
        
        # if user specified a save directory directly with output filename that
        # is different than the current working directory, use it
        [ "$(dirname "$1")" != '.' ] && savedir="$(dirname "$1")"
        
        # if user specified './' as a save directory directly with output
        # filename, use it ('pwd' makes the program output more clear)
        printf '%s' "$1" | grep -q '^\./.*' && savedir="$(pwd)"
        
        # the case that user specifies '../' as a save directory directly with
        # output filename is already covered above in
        # 'if [ "$(dirname "$1")" != "." ]'. here we just use 'dirname "$(pwd)"'
        # to make the program output more clear
        printf '%s' "$1" | grep -q '^\.\./.*' && savedir="$(printf '%s' "$(dirname "$(pwd)")")"
        
        # set the output filename and get the container format (only if saving the output video)
        if [ "$saving_output" = 'true' ] 
        then
            output_file="$(basename "$1")" # set the output filename
            format="${output_file##*.}"    # set container format (output filename extension)
        fi
    else
        # do not allow to use '-u' when not saving the live streaming
        [ "$saving_output" = 'false' ] && exit_program "'-u' is set but not saving the live streaming ('-K' not set)"
        
        # if '-u' is set, don't allow to set an output filename in command line
        [ "$#" -gt '0' ] && exit_program '--auto-filename (-u) does not allow to set an output filename'
        
        # set the output filename
        if [ "$streaming" = 'true' ] 
        then
            output_file="screencast-livestreaming-$(date +%Y-%m-%d_%H.%M.%S).${format}"
        else
            output_file="screencast-$(date +%Y-%m-%d_%H.%M.%S).${format}"
        fi
    fi
    
    # check if user entered a valid container format
    if [ "$format_setted" = 'true' ] ||
       {
           [ "$auto_filename" = 'false' ] &&
           [ "$saving_output" = 'true'  ] ;
       }
    then
        if ! printf '%s' "$supported_formats_all" | grep -q "^${format}$"
        then
           exit_program "'${format}' is not a valid container format for this program"
        fi
    fi
    
    # check for valid live streaming settings
    if [ "$streaming" = 'true' ] 
    then
        get_supported_streaming_settings
        
        # check if the detected ffmpeg build has support for flv muxer (used for live streaming)
        check_component flv muxer || component_error flv muxer false
        
        # do not allow live streaming without recording audio (YouTube seems to refuse it)
        [ "$recording_audio" = 'false' ] && exit_program 'live streaming cannot be sent without audio'
        
        # do not allow to use fade effect with live streaming (-L/--live-streaming)
        [ "$fade" != 'none' ] && exit_program 'fade effect (-e) cannot be used with live streaming (-L)'
        
        # check for an invalid container format if saving the live stream
        # (supported audio/video encoders in the flv muxer that have restrictions in specific container formats)
        if [ "$saving_output" = 'true' ] 
        then
            if ! printf '%s' "$supported_streaming_formats" | grep -q "^${format}$"
            then
                exit_program "live streaming cannot be saved to the '${format}' container format"
            fi
        fi
        
        # check for an invalid audio encoder for live streaming (flv muxer restrictions)
        if ! printf '%s' "$supported_streaming_audiocodecs" | grep -q "^${audio_encoder}$"
        then
            exit_program "live streaming cannot be made with the '${audio_encoder}' audio encoder"
        fi
        
        # check for an invalid video encoder for live streaming (flv muxer restrictions)
        if ! printf '%s' "$supported_streaming_videocodecs" | grep -q "^${video_encoder}$"
        then
            exit_program "live streaming cannot be made with the '${video_encoder}' video encoder"
        fi
    fi
    
    # checks and settings for formats and audio/video encoders when saving the output video
    if [ "$saving_output" = 'true' ] 
    then
        # execute container formats checks and settings
        "format_settings_${format}"
        
        # check if user entered and invalid combination of audio encoder and container format
        if [ "$format_setted" = 'true' ] || [ "$audio_encoder_setted" = 'true' ] 
        then
            if ! printf '%s' "$supported_audiocodecs" | grep -q "^${audio_encoder}$"
            then
                msg="container format '${format}' does not support '${audio_encoder}' audio encoder"
                
                if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
                then
                    msg="${msg}
                      (did you forget to select the container format?)"
                fi
                
                show_settings
                exit_program "$msg"
            fi
        fi
        
        # check if user entered and invalid combination of video encoder and container format
        if [ "$format_setted" = 'true' ] || [ "$video_encoder_setted" = 'true' ] 
        then
            if ! printf '%s' "$supported_videocodecs" | grep -q "^${video_encoder}$"
            then
                msg="container format '${format}' does not support '${video_encoder}' video encoder"
                
                if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
                then
                    msg="${msg}
                      (did you forget to select the container format?)"
                fi
                
                show_settings
                exit_program "$msg"
            fi
            
            # special condition check: mp4 + vp9
            # support is enabled only in ffmpeg 3.4 or greater (or git master N-86119-g5ff31babfc or greater)
            if {
                    [ "$video_encoder" = 'vp9'       ] ||
                    [ "$video_encoder" = 'vp9_vaapi' ] ;
               } &&
               [ "$format" = 'mp4' ] 
            then
                ffmpeg_version="$(ffmpeg -version | grep 'Copyright' | cut -d' ' -f3)"
                
                if {
                       printf '%s' "$ffmpeg_version" | grep -Eq '^[0-9]+\..*' &&
                       ! {
                             [ "$(printf '%s' "$ffmpeg_version" | cut -d'.' -f1)" -ge '3' ] &&
                             [ "$(printf '%s' "$ffmpeg_version" | cut -d'.' -f2)" -ge '4' ] ;
                         } ;
                   } ||
                   {
                       printf '%s' "$ffmpeg_version" | grep -q '^N-.*' &&
                       ! [ "$(printf '%s' "$ffmpeg_version" | cut -d'-' -f2)" -ge '86119' ] ;
                   }
                then
                    msg="support for 'vp9' encoder in 'mp4' container format in your ffmpeg build is experimental
                      it's needed ffmpeg 3.4 or greater (or git master N-86119-g5ff31babfc or greater)"
                    
                    if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
                    then
                        msg="${msg}
                      (did you forget to select the container format?)"
                    fi
                    
                    show_settings
                    exit_program "$msg"
                    
                fi # end: if { <complex multi-line ffmpeg version check>
                
            fi # end: [ "$format" = 'mp4' ] &&
            
        fi # end: [ "$format_setted" = 'true' ] || [ "$video_encoder_setted" = 'true' ]
        
    fi # end: [ "$saving_output" = 'true' ]
    
    # audio input checks and adjustments
    if [ "$recording_audio" = 'true' ] 
    then
        # check if the detected ffmpeg build has support for a lossless audio encoder and decoder for recording
        check_lossless_component audiocodec
        
        # check for ALSA support in ffmpeg (fallback to PulseAudio if ALSA is not available)
        if ! check_component alsa demuxer
        then
            # check for PulseAudio support in ffmpeg
            if check_component pulse demuxer
            then
                audio_input_options="$(printf '%s' "$audio_input_options" | sed 's/alsa/pulse/')"
                
                print_warn 'the detected ffmpeg build has no ALSA support, falling back to PulseAudio backend'
            else
                component_error 'ALSA or PulseAudio' backend false
            fi
            
            if [ "$audio_input_setted" = 'false' ] 
            then
                print_warn "auto setting audio input device to 'default'"
            else
                # check if user entered a valid PulseAudio input source
                case "$audio_input" in
                    default)
                        :
                        ;;
                    *)
                        if command -v pactl >/dev/null 2>&1
                        then
                            if ! printf '%s' "$(pactl list sources |
                                                 grep '[Nn]ame:'   |
                                                 grep 'input'      |
                                                 sed  's/[[:space:]]*[Nn]ame:[[:space:]]//;s/^<//;s/>$//'
                                               )" | grep -q "^${audio_input}$"
                            then
                                exit_program "'${audio_input}' is not a valid PulseAudio input source on this system"
                            fi
                        else
                            print_error "'pactl' was not found after falling back to PulseAudio backend"
                            printf '%s%s\n' '                       ' \
                                            "please install 'pactl'" >&2
                            exit 1
                        fi
                        ;;
                esac
            fi
        else
            # check if user entered a valid ALSA input device name
            if [ "$audio_input_setted" = 'true' ] 
            then
                case "$audio_input" in
                    pulse|default)
                        :
                        ;;
                    # do not allow 'null' ALSA input device
                    null)
                        exit_program "the use of 'null' ALSA input device causes problems and is not allowed"
                        ;;
                    *)
                        if command -v arecord >/dev/null 2>&1
                        then
                            if ! check_alsa_long_name && ! check_alsa_short_name
                            then
                                exit_program "'${audio_input}' is not a valid ALSA input device name on this system"
                            fi
                        else
                            print_error "'arecord' was not found"
                            printf '%s%s\n' '                       ' \
                                            "please install 'arecord' (alsa-utils)" >&2
                            exit 1
                        fi
                        ;;
                esac
            fi
        fi # end: else clause of: if ! check_component alsa demuxer
        
        audio_input="-i ${audio_input}" # add ffmpeg '-i' option for audio input
        
    fi # end: [ "$recording_audio" = 'true' ]
    
    # do not allow to use '-i none' with an '-a' argument different than 'none'
    if [ "$audio_input"    = 'none' ] && [ "$audio_input_setted"   = 'true' ] &&
       [ "$audio_encoder" != 'none' ] && [ "$audio_encoder_setted" = 'true' ] 
    then
        exit_program "'-i none' cannot be used with an '-a' argument different than 'none'"
    fi
    
    # do not allow to use '-a none' with an '-i' argument different than 'none'
    if [ "$audio_encoder"  = 'none' ] && [ "$audio_encoder_setted" = 'true' ] &&
       [ "$audio_input"   != 'none' ] && [ "$audio_input_setted"   = 'true' ] 
       
    then
        exit_program "'-a none' cannot be used with an '-i' argument different than 'none'"
    fi
    
    # execute audio encoder checks and settings (only if recording audio)
    if [ "$recording_audio" = 'true' ] 
    then
        "audiocodec_settings_${audio_encoder}"
    
    # adjust settings if user is not recording audio (video without audio stream)
    else
        unset audio_input
        unset audio_channel_layout
        unset audio_input_options
        audio_record_codec='-an'
        audio_encode_codec='-an'
    fi
    
    # execute video encoder checks and settings
    "videocodec_settings_${video_encoder}"
    
    # do not allow to use -A/--vaapi-device without setting a vaapi video encoder
    case "$video_encoder" in
        *_vaapi)
            :
            ;;
        *)
            [ "$vaapi_device_setted" = 'true' ] && exit_program '--vaapi-device (-A) option can be used only when a VAAPI video encoder is selected'
            unset vaapi_device
            ;;
    esac
    
    # do not allow to use -m option when -i or -a are setted to 'none'
    if [ "$recording_audio" = 'false' ] && [ "$volume_factor_setted" = 'true' ] 
    then
        exit_program "--volume-factor (-m) option cannot be used when '-i' or '-a' are setted to 'none'"
    fi
    
    # check if the entered volume factor is a valid integer/float number (-m)
    if [ "$volume_factor_setted" = 'true' ] 
    then
        if printf '%s' "$volume_factor" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
        then
            # enable volume increase effect if chosen by user
            # (a value different than '1.0' or '0.0')
            if ! {
                     printf '%s' "$volume_factor" | grep -Eq '^[0]+(\.[0]+)?$' ||
                     printf '%s' "$volume_factor" | grep -Eq '^[1]+(\.[0]+)?$' ;
                 }
            then
                volume_options="-af volume=${volume_factor}"
            fi
        else
            exit_program "'${volume_factor}' is not a valid number for volume increase effect"
        fi
    fi
    
    # watermark checks and settings
    if [ "$watermark" = 'true' ] 
    then
        # check for a valid watermark size format (NxN) (-z/--wmark-size)
        printf '%s' "$watermark_size" | grep -Eq '^[0-9]+x[0-9]+$' || exit_program "'${watermark_size}' is not a valid watermark size format"
        
        # check for a valid watermark position format ('N,N' or 'PRE') (-k/--wmark-position)
        if printf '%s' "$watermark_position" | grep -Eq '^[0-9]+,[0-9]+$'
        then
            # translate watermark position to what is really used in ffmpeg command
            watermark_position="$(printf '%s' "$watermark_position" | tr ',' ':')"
        else
            # check for a valid watermark special position value
            if check_special_position "$watermark_position"
            then
                # translate watermark position to what is really used in ffmpeg command
                watermark_corner="$watermark_position" # save for comparing watermark and webcam overlay corners
                watermark_position="$special_position"
                unset special_position
                
                # translate a possible alias to the full corner position name (for comparing with webcam overlay corner)
                case "$watermark_corner" in
                    tr)
                        watermark_corner='topright'
                        ;;
                    br)
                        watermark_corner='bottomright'
                        ;;
                    tl)
                        watermark_corner='topleft'
                        ;;
                    bl)
                        watermark_corner='bottomleft'
                        ;;
                esac
            else
                exit_program "'${watermark_position}' is not a valid watermark position format"
            fi
        fi
    
    # do not allow to use -z, -k, -c or -g options without -w option
    else
        msg='option can be used only with --watermark (-w) option'
        [ "$wmark_size_setted"   = 'true' ] && exit_program "--wmark-size (-z) ${msg}"
        [ "$wmark_posi_setted"   = 'true' ] && exit_program "--wmark-position (-k) ${msg}"
        [ "$wmark_font_setted"   = 'true' ] && exit_program "--wmark-font (-c) ${msg}"
        [ "$pngoptimizer_setted" = 'true' ] && exit_program "--png-optimizer (-g) ${msg}"
        unset msg
    fi
    
    # webcam overlay checks and settings
    if [ "$webcam_overlay" = 'true' ] 
    then
        # check for a valid webcam input device
        [ -c "$webcam_input" ] || exit_program "'${webcam_input}' is not a valid webcam input device on this system"
        
        # check for a valid webcam size format (NxN) (-Z/--webcam-size)
        printf '%s' "$webcam_size" | grep -Eq '^[0-9]+x[0-9]+$' || exit_program "'${webcam_size}' is not a valid webcam size format"
        
        # check for a valid webcam position format ('N,N' or 'PRE') (-P/--webcam-position)
        if printf '%s' "$webcam_position" | grep -Eq '^[0-9]+,[0-9]+$'
        then
            # translate webcam position to what is really used in ffmpeg command
            webcam_position="$(printf '%s' "$webcam_position" | tr ',' ':')"
        else
            # check for a valid webcam special position value
            if check_special_position "$webcam_position"
            then
                # translate webcam position to what is really used in ffmpeg command
                webcam_corner="$webcam_position" # save for comparing watermark and webcam overlay corners
                webcam_position="$special_position"
                unset special_position
                
                # translate a possible alias to the full corner position name (for comparing with watermark corner)
                case "$webcam_corner" in
                    tr)
                        webcam_corner='topright'
                        ;;
                    br)
                        webcam_corner='bottomright'
                        ;;
                    tl)
                        webcam_corner='topleft'
                        ;;
                    bl)
                        webcam_corner='bottomleft'
                        ;;
                esac
            else
                exit_program "'${webcam_position}' is not a valid webcam position format"
            fi
        fi
    
    # do not allow to use -Z, -I, or -P options without -W option
    else
        msg='option can be used only with --webcam (-W) option'
        [ "$webcam_size_setted"  = 'true' ] && exit_program "--webcam-size (-Z) ${msg}"
        [ "$webcam_input_setted" = 'true' ] && exit_program "--webcam-input (-I) ${msg}"
        [ "$webcam_posi_setted"  = 'true' ] && exit_program "--webcam-position (-P) ${msg}"
        [ "$webcam_rate_setted"  = 'true' ] && exit_program "--webcam-fps (-R) ${msg}"
        unset msg
    fi
    
    # do not allow watermark and webcam overlay to be placed in the same video corner (only works with predefined special values)
    [ "$watermark" = 'true' ] && [ "$webcam_overlay" = 'true' ] && [ "$watermark_corner" = "$webcam_corner" ] &&
        exit_program "watermark and webcam overlay cannot be placed in the same '$webcam_corner' video corner"
    
    # check if the entered fixed video length is a valid integer/float number (-x)
    if [ "$fixed_length_setted" = 'true' ] 
    then
        if printf '%s' "$fixed_length" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
        then
            # enable fixed video length if chosen by user (a value different than '0')
            printf '%s' "$fixed_length" | grep -Eq '^[0]+(\.[0]+)?$' || fixed_length_options="-t ${fixed_length}"
        else
            exit_program "'${fixed_length}' is not a valid number for fixed video length"
        fi
    fi
}

# check_dirs function: check for valid output and tmp directories (-o and -t)
#                      (will exit with error if any problem is encountered)
# arguments: none
# return value: not relevant
# return code (status): not relevant
check_dirs() {
    for directory in "$savedir" "$tmpdir"
    do
        # check if the entered $savedir/$tmpdir already exists and mkdir if not
        if ! [ -e "$directory" ] 
        then
            if ! mkdir -p "$directory"
            then
                case "$directory" in
                    "$savedir")
                        msg='output'
                        ;;
                    "$tmpdir")
                        msg='temporary files'
                        ;;
                esac
                exit_program "failed to create ${msg} directory '${directory}'"
            fi
        fi
        
        # check if the entered $savedir/$tmpdir is a directory
        if [ -d "$directory" ] 
        then
            # check if the entered $savedir/$tmpdir has write permission
            if ! [ -w "$directory" ] 
            then
                case "$directory" in
                    "$savedir")
                        msg='output'
                        ;;
                    "$tmpdir")
                        msg='temporary files'
                        ;;
                esac
                exit_program "no write permission for ${msg} directory '${directory}'"
            fi
        else
            exit_program "'${directory}' is not a directory"
        fi
    done
}

# get_region function: select with mouse the screen region to record
#                      (will exit with error if region selection is canceled)
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: sets $video_size and $video_position
get_region() {
    print_good 'please select with mouse a screen region to record...'
    print_info 'single click to select a window, click and drag to select a region'
    print_info 'use arrow keys to fine tune when dragging, right click or any other keystroke to cancel'
    
    screen_region="$(slop -o -f '%x %y %w %h')" || exit_program 'screen region was not selected'
    
    if ! printf '%s' "$screen_region" | grep -Eq '^([0-9]+[[:space:]]){3}[0-9]+$'
    then
        exit_program 'slop returned wrong values'
    fi
    
    video_position_x="$(printf '%s' "$screen_region" | cut -d' ' -f1)"
    video_position_y="$(printf '%s' "$screen_region" | cut -d' ' -f2)"
    video_width="$(     printf '%s' "$screen_region" | cut -d' ' -f3)"
    video_height="$(    printf '%s' "$screen_region" | cut -d' ' -f4)"
    
    # change video width and height if not a multiple of 8
    check_dimension "$video_width"  || adjust_dimension 'width'
    check_dimension "$video_height" || adjust_dimension 'height'
    
    video_size="${video_width}x${video_height}"
    video_position="${video_position_x},${video_position_y}"
}

# randomstr function: generate a random string
# arguments: $1 - desired string length
# return value: a random string
# return code (status): not relevant
randomstr() {
    if [ -c '/dev/urandom' ] 
    then
        LC_CTYPE='C' tr -dc '[:alnum:]' < /dev/urandom | head -c"$1"
        
    elif command -v shuf >/dev/null 2>&1
    then
        alphanum="a b c d e f g h i j k l m n o p q r s t u v w x y z \
                  A B C D E F G H Y J K L M N O P Q R S T U V W X Y Z \
                  0 1 2 3 4 5 6 7 8 9"
        shuf -ez -n"$1" $alphanum
        unset alphanum
        
    elif command -v openssl >/dev/null 2>&1
    then
        openssl rand -hex "$1" | cut -c-"$1"
        
    elif command -v pwgen >/dev/null 2>&1
    then
        pwgen -cns "$1" 1

    else
        print_good 'generating random string with legacy method' >&2
        rnd="$(awk 'BEGIN{srand(); printf "%d\n",(rand() * 10^8)}')"
        
        while [ "$(printf '%s' "$rnd" | wc -m)" -lt "$1" ] 
        do
            sleep 1
            rnd="${rnd}$(awk 'BEGIN{srand(); printf "%d\n",(rand() * 10^8)}')"
        done
        
        printf '%s' "$rnd" | cut -c-"$1"
        unset rnd
    fi
}

# optimize_png function: optimize the png (watermark) image
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: needs $wmark_image
optimize_png() {
    print_good 'optimizing watermark image'
    
    [ "$pngoptimizer" != 'opt-png' ] && "get_pngoptmz_settings_${pngoptimizer}"
    
    "$pngoptimizer" $pngoptmz_settings "$wmark_image"
    
    # use advdef to optimize PNG even more
    get_pngoptmz_settings_advdef
    advdef $advdef_settings "$wmark_image"
}

# create_watermark function: create a text watermark and set watermark options
#                            to be passed to ffmpeg command
# arguments: none
# return value: not relevant
# return code (status): 0 - text watermark image was successfully created
#                       1 - failed to create text watermark image
# sets special variables: $watermark_options - ffmpeg watermark options
create_watermark() {
    print_good 'generating watermark image'
    rndstr_png="$(randomstr '20')" # random string for tmp png filename
    wmark_image="${tmpdir}/screencast-tmpimage-${$}-${rndstr_png}.png"
    
    # get font pointsize
    if watermark_pointsize="$(magick \
                                  -size "$watermark_size" \
                                  -font "$watermark_font" \
                                  label:"$watermark_text" \
                                  -format '%[label:pointsize]' \
                                  info:)"
    then
        # check if font pointsize was correctly obtained (integer/float number)
        if printf '%s' "$watermark_pointsize" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
        then
            # generate the watermark
            if magick \
                   -size "$watermark_size" \
                   -font "$watermark_font" \
                   -pointsize "$watermark_pointsize" \
                   -gravity center \
                   \( \
                       xc:grey30 \
                       -draw "fill gray70  text 0,0  '${watermark_text}'" \
                   \) \
                   \( \
                       xc:black \
                       -draw "fill white  text  1,1  '${watermark_text}'  \
                                          text  0,0  '${watermark_text}'  \
                              fill black  text -1,-1 '${watermark_text}'" \
                       -alpha Off \
                   \) \
                   -alpha Off \
                   -compose copy-opacity \
                   -composite \
                   -trim \
                   +repage \
                   "$wmark_image"
            then
                # check if the generated watermark file is truly a PNG image
                if file "$wmark_image" | grep -q 'PNG image data'
                then
                    # optimize PNG image if chosen by user (-g/--png-optimizer)
                    [ "$pngoptimizer" != 'none' ] && optimize_png
                    
                    # set ffmpeg watermark options
                    watermark_input="-framerate ${video_rate} \
                                     -thread_queue_size ${queue_size} \
                                     -i ${wmark_image}"
                    watermark_input="$(remove_spaces "$watermark_input")"
                    watermark_options="overlay=${watermark_position}"
                else
                    print_warn 'the generated watermark is not a PNG file (watermarking aborted)' >&2
                    return 1
                fi # end: if file
            else
                print_warn 'failed to create watermark image (watermarking aborted)' >&2
                return 1
            fi # end: if magick
        else
            print_warn 'the obtained watermark font pointsize is not a valid integer/float number (watermarking aborted)' >&2
            return 1
        fi # end: if printf
    else
        print_warn 'failed to obtain watermark font pointsize (watermarking aborted)' >&2
        return 1
    fi # end: if watermark_pointsize=
}

# video_fade function: sets video fade options to be passed to ffmpeg command
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variables: $fade_options - ffmpeg fade options
videofade() {
    get_fade_settings
    
    # get recorded video length in seconds
    video_length="$(ffprobe \
                        -i "${tmpdir}/screencast-tmpvideo-${$}-${rndstr_video}.${rec_extension}" \
                        -show_entries format='duration' \
                        -v quiet \
                        -of csv='p=0')"
    
    # set start time of fade-out in seconds
    total_fadeout="$(printf '%s\n' "${fade_length}  + ${fade_solid_length}" | bc)"
    fadeout_start="$(printf '%s\n' "${video_length} - ${total_fadeout}"     | bc)"
    
    # build ffmpeg fade in/out options
    fadein="fade=type=in:start_time=${fade_solid_length}:duration=${fade_length}:color=${fade_color}"
    fadeout="fade=type=out:start_time=${fadeout_start}:duration=${fade_length}:color=${fade_color}"
    
    # check the chosen fade type and set ffmpeg fade options if necessary
    case "$fade" in
        in)
            fade_options="$fadein"
            ;;
        out)
            fade_options="$fadeout"
            ;;
        both)
            fade_options="${fadein},${fadeout}"
            ;;
    esac
}

# set_watermark function: enable watermark effect if chosen by user (-w/--watermark)
# arguments: none
# return value: none
# return code (status): not relevant
set_watermark() {
    if [ "$watermark" = 'true' ] 
    then
        if create_watermark
        then
            vfilter_option='-filter_complex'
            vfilter_settings="${vfilter_settings:+"${vfilter_settings},${watermark_options}"}"
            vfilter_settings="${vfilter_settings:-"$watermark_options"}"
            
            [ "$video_encoder" = 'vp9' ] && pixel_format='yuva420p'
        fi
    fi
}

# set_webcam function: enable webcam overlay effect if chosen by user (-W/--webcam)
# arguments: none
# return value: none
# return code (status): not relevant
set_webcam() {
    if [ "$webcam_overlay" = 'true' ] 
    then
        check_component video4linux2,v4l2 demuxer || component_error video4linux2,v4l2 demuxer false
        
        [ "$webcam_rate_setted" = 'true' ] && webcam_options="-framerate ${webcam_rate}"
        
        webcam_options="${webcam_input_options} ${webcam_options} -video_size ${webcam_size} -i ${webcam_input}"
        
        vfilter_option='-filter_complex'
        vfilter_settings="${vfilter_settings:+"${vfilter_settings},overlay=${webcam_position},format=bgr0"}"
        vfilter_settings="${vfilter_settings:-"overlay=${webcam_position},format=bgr0"}"
    fi
}

# fix_pass_duration function: fix 'pass duration too large' messages in ffmpeg
# arguments: none
# return value: none
# return code (status): not relevant
fix_pass_duration() {
    [ "$webcam_overlay" = 'false' ] && [ "$watermark" = 'false' ] && vfilter_option='-vf'
    vfilter_settings="${vfilter_settings:+"${vfilter_settings},fps=${video_rate}"}"
    vfilter_settings="${vfilter_settings:-"fps=${video_rate}"}"
}

# set_vaapi_qsv function: set needed options for vaapi and qsv hardware accelerated video encoders (-v/--video-encoder)
#                         if they are chosen by the user
# arguments: none
# return value: none
# return code (status): not relevant
set_vaapi_qsv() {
    case "$video_encoder" in
        *_vaapi)
            if [ "$one_step" = 'false' ] 
            then
                [ "$streaming"      = 'false' ] && [ "$watermark" = 'false' ] && [ "$fade" = 'none'  ] && vfilter_option='-vf'
            else
                [ "$webcam_overlay" = 'false' ] && [ "$watermark" = 'false' ] && [ "$fade" = 'none'  ] && vfilter_option='-vf'
            fi
            
            vfilter_settings="${vfilter_settings:+"${vfilter_settings},format=nv12,hwupload"}"
            vfilter_settings="${vfilter_settings:-format=nv12,hwupload}"
            
            vaapi_device="-vaapi_device ${vaapi_device}"
            pixel_format='vaapi_vld'
            ;;
        *_qsv)
            pixel_format='nv12'
            ;;
    esac
}

# finish function: print message and show notification when finished
# arguments: none
# return value: the printed message
# return code (status): not relevant
finish() {
    print_good 'finish'
    
    ! [ -f "$finish_icon" ] && finish_icon='video-x-generic'
    
    notify 'normal' '3000' "$finish_icon" 'finish'
    
    # play a sound after finish if requirements are present
    if command -v ffplay >/dev/null 2>&1
    then
        [ -f "$finish_sound" ] && ffplay -v quiet -nodisp -autoexit -volume "$ffplay_volume" "$finish_sound" >/dev/null 2>&1 &
    fi
}

# recording_error function: exit the program with the proper message/notifications if a recording error has occurred
# arguments: none
# return value: not relevant
# return code (status): not relevant
recording_error() {
    print_error 'recording error!'
    notify 'critical' '5000' 'dialog-error' 'recording error!'
    exit 1
}

# encoding_error function: exit the program with the proper message/notifications if an encoding error has occurred
# arguments: none
# return value: not relevant
# return code (status): not relevant
encoding_error() {
    print_error 'encoding error!'
    notify 'critical' '5000' 'dialog-error' 'encoding error!'
    exit 1
}

# live_streaming function: record and live stream
# arguments: none
# return value: none
# return code (status): not relevant
# note: it will make the program exit with error if a recording error occurs
live_streaming() {
    # set ffmpeg '-maxrate' and '-bufsize' options
    if   [ "$video_height" -gt '2160' ] 
    then
         if [ "$video_rate" -ge '60' ] 
         then
             video_encode_codec="${video_encode_codec} -maxrate 40M -bufsize 80M"
         else
             video_encode_codec="${video_encode_codec} -maxrate 30M -bufsize 60M"
         fi
         
    elif [ "$video_height" -eq '2160' ] 
    then
         if [ "$video_rate" -ge '60' ] 
         then
             video_encode_codec="${video_encode_codec} -maxrate 22M -bufsize 44M"
         else
             video_encode_codec="${video_encode_codec} -maxrate 15M -bufsize 30M"
         fi
         
    elif [ "$video_height" -eq '1440' ] ||
         {
             [ "$video_height" -lt '2160' ] &&
             [ "$video_height" -gt '1440' ] ;
         }
    then
         if [ "$video_rate" -ge '60' ] 
         then
             video_encode_codec="${video_encode_codec} -maxrate 10M -bufsize 20M"
         else
             video_encode_codec="${video_encode_codec} -maxrate 7M -bufsize 14M"
         fi
         
    elif [ "$video_height" -eq '1080' ] ||
         {
             [ "$video_height" -lt '1440' ] &&
             [ "$video_height" -gt '1080' ] ;
         }
    then
         if [ "$video_rate" -ge '60' ] 
         then
             video_encode_codec="${video_encode_codec} -maxrate 5M -bufsize 10M"
         else
             video_encode_codec="${video_encode_codec} -maxrate 4M -bufsize 8M"
         fi
         
    elif [ "$video_height" -eq '720' ] ||
         {
             [ "$video_height" -lt '1080' ] &&
             [ "$video_height" -gt '720'  ] ;
         }
    then
         if [ "$video_rate" -ge '60' ] 
         then
             video_encode_codec="${video_encode_codec} -maxrate 3M -bufsize 6M"
         else
             video_encode_codec="${video_encode_codec} -maxrate 2M -bufsize 4M"
         fi
         
    elif [ "$video_height" -eq '480' ] ||
         {
             [ "$video_height" -lt '720' ] &&
             [ "$video_height" -gt '480' ] ;
         }
    then
         video_encode_codec="${video_encode_codec} -maxrate 1M -bufsize 2M"
         
    elif [ "$video_height" -eq '360' ] ||
         {
             [ "$video_height" -lt '480' ] &&
             [ "$video_height" -gt '360' ] ;
         }
    then
         video_encode_codec="${video_encode_codec} -maxrate 500k -bufsize 1000k"
         
    elif [ "$video_height" -eq '240' ] ||
         {
             [ "$video_height" -lt '360' ] &&
             [ "$video_height" -gt '240' ] ;
         }
    then
         video_encode_codec="${video_encode_codec} -maxrate 400k -bufsize 800k"
         
    else
         video_encode_codec="${video_encode_codec} -maxrate 2M -bufsize 4M"
    fi
    
    video_encode_codec="${video_encode_codec} -g $((video_rate * 2))" # set gop size
    
    set_watermark
    set_webcam
    fix_pass_duration
    set_vaapi_qsv
    
    print_good 'live streaming'
    notify 'normal' '1700' 'media-record' 'live streaming...'
    
    # do the live stream and save the recorded content to an output file
    if [ "$saving_output" = 'true' ] 
    then
        if ffmpeg \
               $audio_input_options \
               $audio_input \
               $vaapi_device \
               $video_input_options \
               -framerate $video_rate \
               -video_size $video_size \
               -i :0.0+${video_position} \
               $watermark_input \
               $webcam_options \
               $vfilter_option $vfilter_settings \
               $volume_options \
               -flags +global_header \
               $audio_encode_codec \
               -codec:v $video_encode_codec \
               $fixed_length_options \
               -pix_fmt $pixel_format \
               -metadata "$metadata" \
               -f tee \
               -map 0:a \
               -map 1:v \
               -y \
               "${faststart}${savedir}/${output_file}|[f=flv]${streaming_url}"
        then
            finish
        else
            recording_error
        fi
    
    # live streaming only, do not save the recorded content to an output file
    else
        if ffmpeg \
               $audio_input_options \
               $audio_input \
               $vaapi_device \
               $video_input_options \
               -framerate $video_rate \
               -video_size $video_size \
               -i :0.0+${video_position} \
               $watermark_input \
               $webcam_options \
               $vfilter_option $vfilter_settings \
               $volume_options \
               $audio_encode_codec \
               -codec:v $video_encode_codec \
               $fixed_length_options \
               -pix_fmt $pixel_format \
               -metadata "$metadata" \
               -f flv \
               -y \
               "$streaming_url"
        then
            finish
        else
            recording_error
        fi
    fi
}

# record_offline_one_step function: record offline (without live streaming) using one step
#                                   (recording and encoding at the same time).
# arguments: none
# return value: none
# return code (status): not relevant
# note: it will make the program exit with error if a recording error occurs
record_offline_one_step() {
    set_watermark
    set_webcam
    fix_pass_duration
    set_vaapi_qsv
    
    print_good 'recording (one step)'
    notify 'normal' '1700' 'media-record' 'recording (one step)...'
    
    # record screen and encode in one step
    if ffmpeg \
           $audio_input_options \
           $audio_input \
           $vaapi_device \
           $video_input_options \
           -framerate $video_rate \
           -video_size $video_size \
           -i :0.0+${video_position} \
           $watermark_input \
           $webcam_options \
           $vfilter_option $vfilter_settings \
           $volume_options \
           $audio_encode_codec \
           -codec:v $video_encode_codec \
           $fixed_length_options \
           -pix_fmt $pixel_format \
           -metadata "$metadata" \
           -y \
           "${savedir}/${output_file}"
    then
        finish
    else
        recording_error
    fi
}

# record_offline_two_steps function: record offline (without live streaming) using two steps
#                                    (1st step: lossless recording. 2nd step: encoding).
# arguments: none
# return value: none
# return code (status): not relevant
# note: it will make the program exit with error if a recording or encoding error occurs
record_offline_two_steps() {
    [ "$webcam_overlay" = 'false' ] && [ "$watermark" = 'true' ] && vfilter_option='-vf'
    
    set_webcam
    fix_pass_duration
    rndstr_video="$(randomstr '20')" # random string for tmp video filename
    print_good 'recording'
    notify 'normal' '1700' 'media-record' 'recording...'
    
    # record screen to a lossless video
    if ffmpeg \
           $audio_input_options \
           $audio_input \
           $video_input_options \
           -framerate $video_rate \
           -video_size $video_size \
           -i :0.0+${video_position} \
           $webcam_options \
           $vfilter_option $vfilter_settings \
           $audio_record_codec \
           -codec:v $video_record_codec \
           $fixed_length_options \
           -metadata "$metadata" \
           -y \
           "${tmpdir}/screencast-tmpvideo-${$}-${rndstr_video}.${rec_extension}"
    then
        unset vfilter_option
        unset vfilter_settings
        
        set_watermark
        
        # enable fade effect if chosen by user (-e/--fade)
        if [ "$fade" != 'none' ] 
        then
            videofade
            [ "$watermark" = 'false' ] && vfilter_option='-vf'
            vfilter_settings="${vfilter_settings:+"${vfilter_settings},${fade_options}"}"
            vfilter_settings="${vfilter_settings:-"${fade_options}"}"
        fi
        
        set_vaapi_qsv
        
        print_good 'encoding'
        notify 'normal' '3000' 'media-playback-stop' 'encoding...'
        
        # encode the recorded lossless video file
        if ffmpeg \
               $audio_channel_layout \
               $vaapi_device \
               -i "${tmpdir}/screencast-tmpvideo-${$}-${rndstr_video}.${rec_extension}" \
               $watermark_input \
               $vfilter_option $vfilter_settings \
               $volume_options \
               $audio_encode_codec \
               -codec:v $video_encode_codec \
               -pix_fmt $pixel_format \
               -metadata "$metadata" \
               $faststart \
               -map 0 \
               -y \
               "${savedir}/${output_file}"
        then
            finish
        else
            encoding_error
        fi
    else
        recording_error
    fi
}

#########################################
#            program start              #
#########################################

trap 'cleanup' EXIT HUP INT QUIT ABRT TERM # signal handling

# check for color output support
if command -v tput >/dev/null 2>&1
then
    color_off="$(tput sgr0)"
    color_bold="${color_off}$(tput bold)"
    color_blue="${color_bold}$(tput setaf 4)"
    color_yellow="${color_bold}$(tput setaf 3)"
    color_red="${color_bold}$(tput setaf 1)"
fi

# message header (colored, will fallback to non-colored if no color support)
msg_header="${color_blue:-}[ ${color_bold:-}screencast${color_blue:-} ]"

# enable some options if the executing shell is zsh
if [ -n "$ZSH_VERSION" ] 
then
    command -v setopt >/dev/null 2>&1 || exit_program 'script appears to be running in zsh but setopt was not found'
    setopt SH_WORD_SPLIT # enable variable word splitting
fi

get_cmd_line "$@"
shift "$shift_count" # destroy all arguments except a possible output filename

# check if a X session is running
[ -z "$DISPLAY" ] && exit_program 'it seems that a X session is not running'

check_pngoptimizer
check_requirements

# prepartions for various checks: get the components supported by the detected ffmpeg build
ffmpeg_formats="$(ffmpeg -formats -v quiet)" # muxers   and demuxers (formats)
ffmpeg_codecs="$( ffmpeg -codecs  -v quiet)" # encoders and decoders

# check if the detected ffmpeg build has support for basic screen recording format
check_component x11grab demuxer || component_error x11grab demuxer false

# check for the needed lossless ffmpeg components when using a two step process
if [ "$streaming" = 'false' ] && [ "$one_step" = 'false' ] 
then
    check_lossless_component format
    check_lossless_component videocodec
fi

check_cmd_line "$@"
check_dirs
show_settings

# show a warning if the output file already exists
[ "$auto_filename" = 'false' ] && [ -f "${savedir}/${output_file}" ] &&
    print_warn "output file '${output_file}' already exists, overwriting without prompt"

# show a warning if using a software-based video encoders in a one step process
if [ "$one_step" = 'true' ] && [ "$streaming" = 'false' ] 
then
    if printf '%s' "$supported_videocodecs_software" | grep -q "^${video_encoder}$"
    then
        print_warn 'using a software-based video encoder in a one step process is not recommend (can cause audio problems)'
    fi
fi

# select with mouse the screen region to record if chosen by user
[ "$select_region" = 'true' ] && get_region && check_screen

# do a live streaming if chosen by user (-L/--live-streaming)
if [ "$streaming" = 'true' ] 
then
    # show a warning if a possible output file already exists
    [ -f "$streaming_url" ] && print_warn "output file '${streaming_url}' already exists, overwriting without prompt"
    
    # show a warning if using a software-based video encoders in live streaming
    if printf '%s' "$supported_videocodecs_software" | grep -q "^${video_encoder}$"
    then
        print_warn 'using a software-based video encoder in live streaming is not recommend (can cause audio problems)'
    fi
    
    live_streaming

# record offline if live streaming is not chosen by user
else
    if [ "$one_step" = 'false' ] 
    then
        record_offline_two_steps
    else
        record_offline_one_step
    fi
fi
