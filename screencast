#!/bin/sh
# shellcheck disable=SC2086

# screencast - POSIX-compliant shell script to record a X11 desktop
#
# Copyright (c) 2015-2017 Daniel Bermond < yahoo.com: danielbermond >
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# program settings
screencast_version='v1.4.0.next'
screencast_website='https://github.com/dbermond/screencast'

# system related settings
savedir="$(pwd)"             # path to save output files
tmpdir='/tmp'                # path for temporary files
queue_size='2048'            # ffmpeg thread queue size
finish_sound='/usr/share/sounds/freedesktop/stereo/complete.oga'

# control settings (controls various aspects)
select_region='false'        # mouse screen region selection (true, false)
auto_filename='false'        # auto choose output filename based on date/time
keep_tmpvideo='false'        # keep temporary video in $tmpdir (true, false)
fade='none'                  # fade effect (in, out, both, none)
watermark='false'            # watermark effect (true, false)
fixed_length='0'             # fixed length video in seconds (0 disable)
notifications='true'         # desktop notifications (true, false)
audio_encoder_setted='false' # if audio encoder  was setted by cmd line with -a
video_encoder_setted='false' # if video encoder  was setted by cmd line with -v
video_size_setted='false'    # if video size     was setted by cmd line with -s
video_posi_setted='false'    # if video position was setted by cmd line with -p
format_setted='false'        # if video format   was setted by cmd line with -f
wmark_size_setted='false'    # if wmark size     was setted by cmd line with -z
wmark_posi_setted='false'    # if wmark position was setted by cmd line with -k
wmark_font_setted='false'    # if wmark font     was setted by cmd line with -c
pngoptimizer_setted='false'  # if png optimizer  was setted by cmd line with -g
outputdir_setted='false'     # if output dir     was setted by cmd line with -o

# audio settings
audio_input='pulse'          # default audio input
audio_encoder='aac'          # default audio encoder
volume_factor='1.0'          # volume increase effect factor (0.0/1.0 disable)
audio_channel_layout='-channel_layout stereo'
audio_general_options="-f alsa -thread_queue_size ${queue_size} -sample_rate 48000 -channels 2 ${audio_channel_layout}"
audio_record_codec='-acodec pcm_s16le -ar 48000 -ac 2'
audio_encode_codec_fdkaac='-acodec libfdk_aac -ab 128k -ar 44100 -ac 2'
audio_encode_codec_aac='-acodec aac -ab 128k -ar 44100 -ac 2'
audio_encode_codec_vorbis='-acodec libvorbis -qscale:a 4 -ar 44100 -ac 2'
audio_encode_codec_opus='-acodec libopus -ab 128k -ar 48000 -ac 2'
audio_encode_codec_mp3lame='-acodec libmp3lame -ab 128k -ar 44100 -ac 2'
audio_encode_codec_shine='-acodec libshine -b 128k -ar 44100 -ac 2'

#video settings
video_encoder='x264'          # default video encoder
pixel_format='yuv420p'        # pixel format
rec_extension='mkv'           # container format (file extension) for recording
format='mp4'                  # container format (file extension) for output
video_position='0,0' #200,234 # X and Y screen coordinates to record video from
video_size='640x480'          # video size (resolution)
video_rate='25'               # video framerate (fps)
video_general_options="-f x11grab -thread_queue_size ${queue_size} -probesize 20M -show_region 1 -region_border 2"
video_record_codec='ffv1 -level 3 -slicecrc 1'
video_record_codec_vp8="${video_record_codec} -pix_fmt yuv420p"
video_encode_codec_x264='libx264 -crf 21 -preset veryslow'
video_encode_codec_h264_nvenc="h264_nvenc -qmin 10 -qmax 42 -preset slow -cq 10 -bf 2 -g 150"
video_encode_codec_x265='libx265 -crf 25 -preset veryslow'
video_encode_codec_kvazaar='libkvazaar -kvazaar-params preset=veryslow'
video_encode_codec_hevc_nvenc='hevc_nvenc -preset slow'
video_encode_codec_theora='libtheora -qscale:v 5'
video_encode_codec_vp8='libvpx -crf 8 -vb 2M'
video_encode_codec_vp9='libvpx-vp9 -crf 30 -vb 0 -speed 0'

# watermark settings
watermark_font='Arial'
watermark_size='255x35'
watermark_position='0,0'
    # good position values for hd720p (1280x720) with default watermark size:
    # 970,10  - top right corner
    # 10,10   - top left  corner
    # 970,688 - bottom right corner
    # 10,688  - bottom left  corner
    # 550,350 - centralized

# png (watermark) optimization settings
pngoptimizer='none'      # truepng, pingo, optipng, opt-png, none
truepngsettings='-o max'
pingosettings='-s8'
optipngsettings='-o 7'
advdefsettings='-z4i10'

# video fade settings
fade_color='black'      # color to be used by the video fade effect
fade_length='0.6'       # length (in seconds) of video fade effect itself
fade_solid_length='0.1' # solid color length (in seconds) of video fade effect

# default options for later comparison (to print informative messages)
audio_encoder_default="$audio_encoder"
video_encoder_default="$video_encoder"
format_default="$format"

# supported arguments (for use with -l/--list)
supported_fade='in, out, both, none'
supported_formats='mp4, mkv, webm, ogg'
supported_aencoders='aac, opus, vorbis, mp3/mp3lame, shine, none'
supported_vencoders="x264, h264_nvenc, x265, kvazaar, hevc_nvenc, theora, vp8, vp9"
supported_pngopt='truepng, pingo, optipng, opt-png, none'

#########################################
#              functions                #
#########################################

# cleanup function: delete unneeded files
# arguments: none
# return value: none
# return code (status): not relevant
cleanup() {
    # delete temporary files
    rm -f "${tmpdir}/screencast-tmpimage-${$}-${randomstring_png}.png"
    [ "$keep_tmpvideo" = 'false' ] && rm -f "${tmpdir}/screencast-tmpvideo-${tmpvideo_volatile}"
    
    # delete zero-sized output file in case some unexpected error occurred
    if [ -f "${savedir}/${output_file}" ] 
    then
        output_filesize="$(du -k "${savedir}/${output_file}" | cut -f1)"
        [ "$output_filesize" -eq '0' ] && rm -f "${savedir}/${output_file}"
    fi
}

# print_good, print_info, print_warn and print_error functions:
# print a formated message with colors if avaiable, otherwise it will fallback
# to non-color output (note: print_error() prints to stderr by default)
# arguments: $1 - message to print
# return value: the message to print
# return code (status): not relevant
print_good() {
    printf '%s\n' "${msg_header}${color_off:-} ${1}"
}

print_info() {
    printf '%s\n' "${msg_header}${color_bold:-} info:${color_off:-} ${1}"
}

print_warn() {
    printf '%s\n' "${msg_header}${color_yellow:-} warning:${color_off:-} ${1}"
}

print_error() {
    printf '%s\n' "${msg_header}${color_red:-} error:${color_off:-} ${1}" >&2
}

# show_header function: show program header
# arguments: none
# return value: the program header
# return code (status): not relevant
show_header() {
    printf '%s\n' "screencast ${screencast_version} - Command line interface to record a X11 desktop"
    printf '%s\n' "Copyright (c) 2015-$(date +%Y) Daniel Bermond"
    printf '%s\n' "$screencast_website"
}

# help function
# arguments: none
# return value: the program help screen
# return code (status): not relevant
show_help() {
    show_header
    printf '\n'
    printf '%s\n' 'Usage: screencast [options] <output>'
    printf '%s\n' '                  [options] -u'
    printf '\n'
    printf '%s\n' "  -s, --size=NxN           video size (resolution) [${video_size}]"
    printf '%s\n' "  -p, --position=N,N       recording position (screen XY top left offsets) [${video_position}]"
    printf '%s\n' '  -S, --select-region      select with mouse the screen region to record'
    printf '%s\n' "  -r, --fps=N              video framerate (fps) [${video_rate}]"
    printf '%s\n' "  -f, --format=TYPE        container format (to use with -u) [${format}]"
    printf '%s\n' "  -i, --audio-input=NAME   audio input device [${audio_input}]"
    printf '%s\n' "  -a, --audio-encoder=NAME audio encoder [${audio_encoder}]"
    printf '%s\n' "  -v, --video-encoder=NAME video encoder [${video_encoder}]"
    printf '%s\n' "  -e, --fade=TYPE          video fade effect [${fade}]"
    printf '%s\n' "  -m, --volume-factor=N    volume increase effect factor (1.0 disable) [${volume_factor}]"
    printf '%s\n' '  -w, --watermark=TEXT     enable and set text watermark [disabled]'
    printf '%s\n' "  -z, --wmark-size=NxN     watermark image size [${watermark_size}]"
    printf '%s\n' "  -k, --wmark-position=N,N watermark position (video XY top left offsets) [${watermark_position}]"
    printf '%s\n' "  -c, --wmark-font=NAME    watermark font [${watermark_font}]"
    printf '%s\n' "  -x, --fixed=N            fixed video length for N seconds (0 disable) [${fixed_length}]"
    printf '%s\n' '  -n, --no-notifications   disable desktop notifications'
    printf '%s\n' "  -g, --png-optimizer=NAME use png (watermark) optimizer and advdef [${pngoptimizer}]"
    printf '%s\n' '  -o, --output-dir=DIR     save videos to DIR (to use with -u) [local directory]'
    printf '%s\n' "  -t, --tmp-dir=DIR        use DIR for temporary files [${tmpdir}]"
    printf '%s\n' "  -K, --keep-tmpvideo      keep (don't delete) the temporary video"
    printf '%s\n' '  -u, --auto-filename      auto choose output filename based on date/time'
    printf '%s\n' '  -l, --list               list arguments supported by these options'
    printf '%s\n' '  -h, --help               this help screen'
    printf '%s\n' '  -V, --version            version information'
    printf '\n'
    printf '%s\n' "For further help run 'man screencast'"
}

# notify function: show a desktop notification if setted to do so
# arguments: $1 - urgency level (low, normal, critial)
#            $2 - duration in milliseconds
#            $3 - icon name
#            $4 - text message
# return value: none
# return code (status): not relevant
notify() {
    notify_args="--urgency=${1} --expire-time=${2} --icon=${3}"
    [ "$notifications" = 'true' ] && notify-send $notify_args screencast "$(remove_spaces "$4")"
}

# check_requirements function: check if required programs are installed
# arguments: none
# return value: not relevant
# return code (status): not relevant
check_requirements() {
    # note: although bc is defined by POSIX, some GNU/Linux distributions
    #       does not include it by default (e.g.: Arch Linux)
    for requirement in notify-send  ffmpeg   xdpyinfo  slop             ffprobe \
                       bc           convert  magick    "$pngoptimizer"  advdef
    do
        # skip disabled components (unnecessary checks)
        if {
               [ "$requirement"   = 'slop'  ] &&
               [ "$select_region" = 'false' ] ;
           } ||
           {
               {
                   [ "$requirement" = 'ffprobe' ] ||
                   [ "$requirement" = 'bc'      ] ;
               } &&
               [ "$fade" = 'none'  ] ;
           } ||
           {
               {
                   [ "$requirement" = 'convert' ] ||
                   [ "$requirement" = 'magick'  ] ;
               } &&
               [ "$watermark" = 'false'  ] ;
           } ||
           {
               [ "$requirement"  = "$pngoptimizer" ] &&
               [ "$pngoptimizer" = 'none'          ] ;
           } ||
           {
               [ "$requirement"  = 'advdef' ] &&
               [ "$pngoptimizer" = "none"   ] ;
           } ||
           {
               [ "$requirement"   = 'notify-send' ] &&
               [ "$notifications" = 'false'       ] ;
           }
        then
            continue
        fi
        
        case "$requirement" in
            notify-send)
                unset request_string
                installname="${requirement} (libnotify) (or use '-n')"
                ;;
            ffmpeg)
                unset request_string
                installname='ffmpeg (version git master preferred)'
                ;;
            ffprobe)
                request_string='video fade effect was requested but '
                installname='ffprobe (ffmpeg) (version git master preferred)'
                ;;
            bc)
                request_string='video fade effect was requested but '
                installname="$requirement"
                ;;
            convert|magick)
                request_string='text watermark was requested but '
                installname='ImageMagick (IM7 preferred)'
                ;;
            slop)
                request_string='screen region selection was requested but '
                installname="$requirement"
                ;;
            "$pngoptimizer")
                request_string='png optimization was requested but '
                installname="$requirement"
                ;;
            advdef)
                request_string='png optimization was requested but '
                installname="${requirement} (advancecomp)"
                ;;
            *)
                unset request_string
                installname="$requirement"
                ;;
        esac
        
        if ! command -v "$requirement" >/dev/null 2>&1
        then
            if [ "$requirement"  = 'magick' ] 
            then
                # in this case IM6 was found because 'convert' goes first
                magick() {
                    convert "$@"
                }
                continue
            else
                msg="${request_string:-}'${requirement}' was not found"
                print_error "$msg"
                printf '%s%s\n' '                      ' \
                          "please install ${installname}" >&2
                [ "$requirement" != 'notify-send' ] &&
                    notify 'critical' '5000' 'process-stop' "$msg"
                exit 1
            fi
        fi
    done
}

# command_error function: print an error message regarding invalid command
#                         line arguments, show notification and exit with error
# arguments: $1 - command line option name (e.g.: "--fade (-e)")
# return value: not relevant
# return code (status): not relevant
command_error() {
    msg='option requires an argument'
    print_error "${1} ${msg}"
    notify 'critical' '5000' 'process-stop' "error: ${1} ${msg}"
    exit 1
}

# exit_program: print an error message to stderr, a desktop notification
#               (if it is enabled) and exit with error
# arguments: $1 - error message to print/notificate
# return value: not relevant
# return code (status): not relevant
exit_program() {
    print_error "${1}"
    notify 'critical' '5000' 'process-stop' "error: ${1}"
    exit 1
}

# remove_spaces function: remove two or more consecutive spaces from a string,
#                         making them to be a single space
# arguments: $1 - the string to modify
# return value: a modified string
# return code (status): not relevant
remove_spaces() {
    printf '%s' "$1" | sed 's/[[:space:]]\+/ /g'
}

# list_supported function: print a list of arguments supported by this program
# arguments: none
# return value: the described list
# return code (status): not relevant
list_supported() {
    show_header
    printf '\n'
    printf '%s\n' ' Supported arguments:'
    printf '\n'
    printf '%s\n' "  -f, --format             $(printf '%s' "$supported_formats")"
    printf '%s\n' "  -a, --audio-encoder      $(printf '%s' "$supported_aencoders")"
    printf '%s\n' "  -v, --video-encoder      $(printf '%s' "$supported_vencoders")"
    printf '%s\n' "  -e, --fade               $(printf '%s' "$supported_fade")"
    printf '%s\n' "  -g, --png-optimizer      $(printf '%s' "$supported_pngopt")"
    printf '\n'
    printf '%s\n' '  NOTE: selecting vorbis or opus audio encoders actually uses the higher'
    printf '%s\n' '        quality libvorbis and libopus encoders respectively.'
    printf '\n'
    printf '%s\n' '  NOTE: mkv is the only container format that supports all audio and video'
    printf '%s\n' '        encoders. Restrictions apply to other container formats.'
    }

# get_cmd_line function: get command line arguments and adjust related variables
# arguments: $1 - the positional parameters passed with double quotes ("$@")
# return value: none
# return code (status): not relevant
# sets special variables: $shift_count - how many shifts were executed
get_cmd_line() {
    shift_count='0' # counts how many 'shift' commands were executed
    
    while :
    do
        # since this is a very long case statement only the first block will
        # be commented. almost all other blocks follows the same sequence/logic
        # and comments will be inserted only for what is different.
        case "$1" in
            # short option and long option without '='
            -s|--size)
                # search for an argument
                if [ -n "$2" ] 
                then
                    # errors out if no argument was entered after the option
                    # (will check for a leading '-' in the next parameter,
                    #  meaning that another option was found)
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--size (-s)'
                    else
                        video_size="$2"
                        video_size_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                # errors out if no argument is found
                else
                    command_error '--size (-s)'
                fi
                ;;
            # long option with '='
            --size=?*)
                video_size="${1#*=}" # assign value after '='
                video_size_setted='true'
                ;;
            # errors out if a long option with '=' has nothing following '='
            --size=)
                command_error '--size (-s)'
                ;;
            
            -p|--position)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--position (-p)'
                    else
                        video_position="$2"
                        video_posi_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--position (-p)'
                fi
                ;;
            --position=?*)
                video_position="${1#*=}"
                video_posi_setted='true'
                ;;
            --position=)
                command_error '--position (-p)'
                ;;
            
            -S|--select-region) # option without argument
                select_region='true'
                ;;
            
            -r|--fps)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fps (-r)'
                    else
                        video_rate="$2"
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fps (-r)'
                fi
                ;;
            --fps=?*)
                video_rate="${1#*=}"
                ;;
            --fps=)
                command_error '--fps (-r)'
                ;;
            
            -f|--format)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--format (-f)'
                    else
                        format="$2"
                        format_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--format (-f)'
                fi
                ;;
            --format=?*)
                format="${1#*=}"
                format_setted='true'
                ;;
            --format=)
                command_error '--format (-f)'
                ;;
            
            -i|--audio-input)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--audio-input (-i)'
                    else
                        audio_input="${2}" # assign value to corresponding var
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--audio-input (-i)'
                fi
                ;;
            --audio-input=?*)
                audio_input="${1#*=}"
                ;;
            --audio-input=)
                command_error '--audio-input (-i)'
                ;;
            
            -a|--audio-encoder)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--audio-encoder (-a)'
                    else
                        audio_encoder="$2"
                        audio_encoder_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--audio-encoder (-a)'
                fi
                ;;
            --audio-encoder=?*)
                audio_encoder="${1#*=}"
                audio_encoder_setted='true'
                ;;
            --audio-encoder=)
                command_error '--audio-encoder (-a)'
                ;;
            
            -v|--video-encoder)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--video-encoder (-v)'
                    else
                        video_encoder="$2"
                        video_encoder_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--video-encoder (-v)'
                fi
                ;;
            --video-encoder=?*)
                video_encoder="${1#*=}"
                video_encoder_setted='true'
                ;;
            --video-encoder=)
                command_error '--video-encoder (-v)'
                ;;
            
            -e|--fade)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fade (-e)'
                    else
                        fade="$2"
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fade (-e)'
                fi
                ;;
            --fade=?*)
                fade="${1#*=}"
                ;;
            --fade=)
                command_error '--fade (-e)'
                ;;
            
            -m|--volume-factor)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--volume-factor (-u)'
                    else
                        volume_factor="$2"
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--volume-factor (-m)'
                fi
                ;;
            --volume-factor=?*)
                volume_factor="${1#*=}"
                ;;
            --volume-factor=)
                command_error '--volume-factor (-m)'
                ;;
            
            -w|--watermark)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--watermark (-w)'
                    else
                        watermark_text="$2"
                        watermark='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--watermark (-w)'
                fi
                ;;
            --watermark=?*)
                watermark_text="${1#*=}"
                watermark='true'
                ;;
            --watermark=)
                command_error '--watermark (-w)'
                ;;
            
            -z|--wmark-size)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-size (-z)'
                    else
                        watermark_size="$2"
                        wmark_size_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-size (-z)'
                fi
                ;;
            --wmark-size=?*)
                watermark_size="${1#*=}"
                wmark_size_setted='true'
                ;;
            --wmark-size=)
                command_error '--wmark-size (-z)'
                ;;
            
            -k|--wmark-position)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-position (-k)'
                    else
                        watermark_position="$2"
                        wmark_posi_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-position (-k)'
                fi
                ;;
            --wmark-position=?*)
                watermark_position="${1#*=}"
                wmark_posi_setted='true'
                ;;
            --wmark-position=)
                command_error '--wmark-position (-k)'
                ;;
            
            -c|--wmark-font)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--wmark-font (-c)'
                    else
                        watermark_font="$2"
                        wmark_font_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--wmark-font (-c)'
                fi
                ;;
            --wmark-font=?*)
                watermark_font="${1#*=}"
                wmark_font_setted='true'
                ;;
            --wmark-font=)
                command_error '--wmark-font (-c)'
                ;;
            
            -x|--fixed)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--fixed (-x)'
                    else
                        fixed_length="$2"
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--fixed (-x)'
                fi
                ;;
            --fixed=?*)
                fixed_length="${1#*=}"
                ;;
            --fixed=)
                command_error '--fixed (-x)'
                ;;
            
            -n|--no-notifications)  # option without argument
                notifications='false'
                ;;
            
            -g|--png-optimizer)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--png-optimizer (-g)'
                    else
                        pngoptimizer="$2"
                        pngoptimizer_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--png-optimizer (-g)'
                fi
                ;;
            --png-optimizer=?*)
                pngoptimizer="${1#*=}"
                pngoptimizer_setted='true'
                ;;
            --png-optimizer=)
                command_error '--png-optimizer (-g)'
                ;;
            
            -o|--output-dir)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--output-dir (-o)'
                    else
                        savedir="${2%/}" # remove ending '/' if present
                        outputdir_setted='true'
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--output-dir (-o)'
                fi
                ;;
            --output-dir=?*)
                savedir="${1#*=}"
                savedir="${savedir%/}" # remove ending '/' if present
                outputdir_setted='true'
                ;;
            --output-dir=)
                command_error '--output-dir (-o)'
                ;;
            
            -t|--tmp-dir)
                if [ -n "$2" ] 
                then
                    if printf '%.1s\n' "$2" | grep -q '-'
                    then
                        command_error '--tmp-dir (-t)'
                    else
                        tmpdir="${2%/}" # remove ending '/' if present
                        shift && shift_count="$((shift_count + 1))"
                    fi
                else
                    command_error '--tmp-dir (-t)'
                fi
                ;;
            --tmp-dir=?*)
                tmpdir="${1#*=}"
                tmpdir="${tmpdir%/}" # remove ending '/' if present
                ;;
            --tmp-dir=)
                command_error '--tmp-dir (-t)'
                ;;
            
            -K|--keep-tmpvideo) # option without argument
                keep_tmpvideo='true'
                ;;
            
            -u|--auto-filename) # option without argument
                auto_filename='true'
                ;;
            
            -l|--list)  # option without argument
                list_supported
                exit 0
                ;;
            
            -h|-\?|--help)  # option without argument
                show_help
                exit 0
                ;;
            
            -V|--version)  # option without argument
                show_header
                exit 0
                ;;
            
            --)   # check for the end of options marker '--'
                shift && shift_count="$((shift_count + 1))"
                break
                ;;
            
            -?*=?*) # unknown option with '=', handle argument also with '='
                exit_program "unknown option '${1%%=*}'"
                ;;
            
            -?*=) # unknown option with '='
                exit_program "unknown option '${1%=*}'"
                ;;
            
            -?*)
                exit_program "unknown option '${1}'"
                ;;
            
            *)    # no more options left
                break
        esac
        shift && shift_count="$((shift_count + 1))"
    done
}

# show_settings function: show information about some program settings
# arguments: none
# return value: program settings information
# return code (status): not relevant
show_settings() {
    [ "$video_encoder" = "$video_encoder_default" ] && [ "$video_encoder_setted" = 'false' ] && video_outstr='(default)'
    [ "$audio_encoder" = "$audio_encoder_default" ] && [ "$audio_encoder_setted" = 'false' ] && audio_outstr='(default)'
    [ "$format"        = "$format_default"        ] && [ "$format_setted"        = 'false' ] &&
        [ "$auto_filename" = 'true'  ] && format_outstr='(default)'
    
    [ "$fade" != 'none' ] && effects="fade-${fade}"
    if [ "$watermark" = 'true' ] 
    then
        effects="${effects:+"${effects}, watermark"}"
        effects="${effects:-watermark}"
    fi
    if [ -n "$volume_options" ] 
    then
        effects="${effects:+"${effects}, volume (${volume_factor})"}"
        effects="${effects:-"volume (${volume_factor})"}"
    fi
    
    effects="${effects:-none}"
    print_good "${color_bold:-}video encoder   :${color_off:-} ${video_encoder} ${video_outstr:-}"
    print_good "${color_bold:-}audio encoder   :${color_off:-} ${audio_encoder} ${audio_outstr:-}"
    print_good "${color_bold:-}container format:${color_off:-} ${format} ${format_outstr:-}"
    print_good "${color_bold:-}effects         :${color_off:-} ${effects}"
}

# ffmpeg_msg function: print an error message and show an error notification
#                      about a not found ffmpeg component (to be used with 
#                      check_ffmpeg_format() and check_ffmpeg_encoder())
# arguments: $1 - string with the not found ffmpeg component
# return value: not relevant
# return code (status): not relevant
ffmpeg_msg() {
    print_error "the detected ffmpeg build has no support for '${1}'"
    printf '%s%s\n'   '                      ' \
                      "please install a ffmpeg build with support for '${1}'" >&2
    notify 'critical' '5000' 'process-stop' "error: ${1} is not supported by your ffmpeg build"
}

# check_ffmpeg_format function: check if detected ffmpeg build has support
#                               for a given format
# arguments: $1 - format generic name
# arguments: $2 - format specific name
# return value: not relevant
# reutrn code (status): 0 - ffmpeg build has support for desired format
#                       1 - ffmpeg build has no support for desired format
# note: needs $ffmpeg_formats - ffmpeg_formats="$(ffmpeg -formats -v quiet)"
check_ffmpeg_format() {
    if ! printf '%s' "$ffmpeg_formats" | grep -q ".*${1}[[:space:]]*${2}.*"
    then
        ffmpeg_msg "$1"
        return 1
    fi
}

# check_ffmpeg_encoder function: check if detected ffmpeg build has support
#                                for a given encoder
# arguments: $1 - encoder generic name
# arguments: $2 - encoder specific name
# return value: not relevant
# reutrn code (status): 0 - ffmpeg build has support for desired encoder
#                       1 - ffmpeg build has no support for desired encoder
# note: needs $ffmpeg_encoders - ffmpeg_encoders="$(ffmpeg -codecs -v quiet)"
check_ffmpeg_encoder() {
    if ! printf '%s' "$ffmpeg_encoders" | grep -q ".*${1}.*encoders:.*${2}.*"
    then
        [ "$2" != 'libfdk_aac' ] && ffmpeg_msg "$2"
        return 1
    fi
}

# dimension_msg function: create an error/warning message to use with
#                         a given inappropriate video dimension
# arguments: $1 - a string denoting the given dimension (width/height)
# return value: a string with the created message
# return code (status): not relevant
dimension_msg() {
    case "$video_encoder" in
        x264|h264_nvenc|hevc_nvenc)
            msg='(this can lead to a speedloss)'
            ;;
        x265|kvazaar|theora|vp8|vp9)
            msg="(${video_encoder} requirement)"
            ;;
    esac
    
    case "$1" in
        width)
            printf '%s' "video width '${video_width}' is not a multiple of 8 ${msg}"
            ;;
        height)
            printf '%s' "video height '${video_height}' is not a multiple of 8 ${msg}"
            ;;
        # no need to exit since it's usually called from a subshell
        *)
            printf '%s' "dimension_msg(): invalid \$1 '${1}'"
            ;;
    esac
    
    unset msg
}

# check_dimension function: check if a given dimension is a multiple of 8
# arguments:  $1 - the given dimension (the actual variable value)
# return value: none
# return code (status): 0 - the dimension is a multiple of 8
#                       1 - the dimension is not a multiple of 8
check_dimension() {
    dimension_value="$1"
    
    # the dimension will be a multiple of 8 if the remainder is 0
    [ "$((dimension_value % 8))" = '0' ] || return 1
}

# adjust_dimension function: change a given dimension to the immediately higher
#                            number that is a multiple of 8
# arguments: $1 - a string denoting the given dimension (width/height)
# return value = not relevant
# return code (status): not relevant
adjust_dimension() {
    dimension="$1"
    
    # get the dimension value denoted by the string in $dimension
    case "$dimension" in
        width)
            dimension_value="$video_width"
            ;;
        height)
            dimension_value="$video_height"
            ;;
        *)
            exit_program "adjust_dimension(): invalid dimension '${dimension}'"
            ;;
    esac
    
    # obtain the next multiple of 8 number
    remainder="$((dimension_value % 8))"
    to_reach="$((8 - remainder))"
    new_dimension_value="$((dimension_value + to_reach))"
    
    print_warn "$(dimension_msg "$dimension") and was changed to '${new_dimension_value}'"
    
    # change the given dimension to the new value
    case "$dimension" in
        width)
            video_width="$new_dimension_value"
            ;;
        height)
            video_height="$new_dimension_value"
            ;;
    esac
}

# check_screen function: check for valid video size and position in relation to the current screen size
#                        (will exit with error if any problem is encountered)
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: needs $video_width, $video_position_x, $video_height and $video_position_y
check_screen() {
    screen_size="$(xdpyinfo | grep 'dimensions' | head -n1 | awk '{ print $2 }')"
    screen_width="$( printf '%s' "$screen_size" | cut -d 'x' -f1)"
    screen_height="$(printf '%s' "$screen_size" | cut -d 'x' -f2)"
    
    if [ "$((video_width + video_position_x))" -gt "$screen_width"  ] 
    then
        exit_program 'recording area is out of screen bounds
                      (video width + position X is greater than the current screen width)'
    fi
    
    if [ "$((video_height + video_position_y))" -gt "$screen_height" ] 
    then
        exit_program 'recording area is out of screen bounds
                      (video height + position Y is greater than the current screen height)'
    fi
}

# check_pngoptimizer function: check for a valid png optimizer (-g/--png-optimizer)
#                              (will exit with error if an invalid png optimizer is chosen)
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: this png optimizer check should be on check_cmd_line(), but it is implemented
#       as a separate function to allow it to be executed before check_requirements()
check_pngoptimizer() {
    case "$pngoptimizer" in
        truepng|pingo|optipng|opt-png|none)
            :
            ;;
        *)
            exit_program "'$pngoptimizer' is not a valid PNG optimizer for this program"
            ;;
    esac
}

# check_cmd_line function: check validity of command line options and arguments (aslo set some variables)
#                          (will exit with error if any inconsistency is found)
# arguments: the remainder positional parameters passed with double quotes ("$@")
# return value: none
# return code (status): not relevant
check_cmd_line() {
    if [ "$select_region" = 'true' ] 
    then
        # do not allow to use -S/--select-region with -s/--size or -p/--position
        [ "$video_size_setted" = 'true' ] && exit_program '--select-region (-S) option cannot be used with --size (-s) option'
        [ "$video_posi_setted" = 'true' ] && exit_program '--select-region (-S) option cannot be used with --position (-p) option'
    else
        # check for a valid video size format (NxN) (-s/--size)
        printf '%s' "$video_size" | grep -Eq '^[0-9]+x[0-9]+$' || exit_program "'${video_size}' is not a valid video size format"
        
        # check for a valid screen position format to record (N,N) (-p/--position)
        printf '%s' "$video_position" | grep -Eq '^[0-9]+,[0-9]+$' || exit_program "'${video_position}' is not a valid screen position format"
        
        # preparations for check_dimension() and check_screen()
        video_position_x="$(printf '%s' "$video_position" | cut -d ',' -f1)"
        video_position_y="$(printf '%s' "$video_position" | cut -d ',' -f2)"
        video_width="$(     printf '%s' "$video_size"     | cut -d 'x' -f1)"
        video_height="$(    printf '%s' "$video_size"     | cut -d 'x' -f2)"
        
        # check if video width and height are a multiple of 8
        check_dimension "$video_width"  || exit_program "$(dimension_msg 'width')"
        check_dimension "$video_height" || exit_program "$(dimension_msg 'height')"
        
        check_screen
    fi
    
    # check if entered framerate (fps) is a valid integer/float number (-r/--fps)
    printf '%s' "$video_rate" | grep -Eq '^[0-9]+(\.[0-9]+)?$' || exit_program "'${video_rate}' is not a valid video framerate (fps) format"
    
    # if '-u' is not set, make some needed checks and settings
    if [ "$auto_filename" = 'false' ] 
    then
        # check if user have not entered an output filename after the options
        [ "$#" -eq '0' ] && exit_program "you must enter an output filename with extension (or use '-u')"
        
        # do not allow to enter anything after the output filename
        [ "$#" -gt '1' ] && exit_program 'please do not enter anything after the output filename'
        
        # do not allow to use -f/--format when specifying an output filename
        if [ "$format_setted" = "true" ] 
        then
            exit_program "--format (-f) option is to be used only with --auto-filename (-u)
                      (when not using '-u', set format in the output filename)"
        fi
        
        # do not allow to use -o/--output-dir when specifying an output filename
        if [ "$outputdir_setted" = "true" ] 
        then
            exit_program "--output-dir (-o) option is to be used only with --auto-filename (-u)
                      (when not using '-u', set output directory with the output filename)"
        fi
        
        # if user specified a save directory directly with output filename that
        # is different than the current working directory, use it
        [ "$(dirname "$1")" != '.' ] && savedir="$(dirname "$1")"
        
        # if user specified './' as a save directory directly with output
        # filename, use it ('pwd' makes the program output more clear)
        printf '%s' "$1" | grep -q '^\./.*' && savedir="$(pwd)"
        
        # the case that user specifies '../' as a save directory directly with
        # output filename is already covered above in
        # 'if [ "$(dirname "$1")" != "." ]'. here we just use 'dirname "$(pwd)"'
        # to make the program output more clear
        printf '%s' "$1" | grep -q '^\.\./.*' && savedir="$(printf '%s' "$(dirname "$(pwd)")")"
        
        # get output filename extension and assign to container format
        format="$(basename "$1")"
        format="${format##*.}"
    # if '-u' is set, don't allow to set an output filename in command line
    else
        [ "$#" -gt '0' ] && exit_program '--auto-filename (-u) does not allow to set an output filename'
    fi
    
    # check if a valid container format was selected; auto choose audio/video
    # encoder if user specified only the format without the encoders
    case "$format" in
        # no need to adjust encoders (default settings are for mp4)
        mp4)
            faststart='-movflags +faststart'
            ;;
        # no action needed (mkv accepts a combination of all encoders)
        mkv)
            :
            ;;
        webm)
            [ "$audio_encoder_setted" = 'false' ] && audio_encoder='opus' && audio_outstr='(auto chosen)'
            [ "$video_encoder_setted" = 'false' ] && video_encoder='vp9'  && video_outstr='(auto chosen)'
            ;;
        ogg)
            [ "$audio_encoder_setted" = 'false' ] && audio_encoder='vorbis' && audio_outstr='(auto chosen)'
            [ "$video_encoder_setted" = 'false' ] && video_encoder='theora' && video_outstr='(auto chosen)'
            ;;
        *)
            exit_program "'${format}' is not a valid container format for this program"
            ;;
    esac
    
    ffmpeg_encoders="$(ffmpeg -codecs -v quiet)" # preparation for check_ffmpeg_encoder()
    
    # check for a valid audio encoder and set recording and encoding options accordingly
    case "$audio_encoder" in
        aac)
            if check_ffmpeg_encoder aac libfdk_aac
            then
                audio_encode_codec="$audio_encode_codec_fdkaac"
            else
                audio_encode_codec="$audio_encode_codec_aac"
            fi
            ;;
        vorbis)
            check_ffmpeg_encoder vorbis libvorbis || exit 1
            audio_encode_codec="$audio_encode_codec_vorbis"
            ;;
        opus)
            check_ffmpeg_encoder opus libopus || exit 1
            audio_encode_codec="$audio_encode_codec_opus"
            ;;
        mp3|mp3lame)
            check_ffmpeg_encoder mp3 libmp3lame || exit 1
            audio_encode_codec="$audio_encode_codec_mp3lame"
            ;;
        shine)
            check_ffmpeg_encoder mp3 libshine || exit 1
            audio_encode_codec="$audio_encode_codec_shine"
            ;;
        # video without audio stream (audio will not be recorded)
        none)
            unset audio_input
            unset audio_channel_layout
            unset audio_general_options
            audio_record_codec='-an'
            audio_encode_codec='-an'
            ;;
        *)
            exit_program "'${audio_encoder}' is not a valid audio encoder for this program"
            ;;
    esac
    
    # check for a video encoder and set recording and encoding options accordingly
    case "$video_encoder" in
        x264)
            check_ffmpeg_encoder h264 libx264 || exit 1
            video_encode_codec="$video_encode_codec_x264"
            ;;
        h264_nvenc)
            check_ffmpeg_encoder h264 h264_nvenc || exit 1
            video_encode_codec="$video_encode_codec_h264_nvenc"
            ;;
        x265)
            check_ffmpeg_encoder hevc libx265 || exit 1
            video_encode_codec="$video_encode_codec_x265"
            ;;
        kvazaar)
            check_ffmpeg_encoder hevc libkvazaar || exit 1
            video_encode_codec="$video_encode_codec_kvazaar"
            ;;
        hevc_nvenc)
            check_ffmpeg_encoder hevc hevc_nvenc || exit 1
            video_encode_codec="$video_encode_codec_hevc_nvenc"
            ;;
        theora)
            check_ffmpeg_encoder theora libtheora || exit 1
            video_encode_codec="$video_encode_codec_theora"
            ;;
        vp8)
            check_ffmpeg_encoder vp8 libvpx || exit 1
            video_record_codec="$video_record_codec_vp8"
            video_encode_codec="$video_encode_codec_vp8"
            ;;
        vp9)
            check_ffmpeg_encoder vp9 libvpx-vp9 || exit 1
            video_encode_codec="$video_encode_codec_vp9"
            ;;
        *)
            exit_program "'${video_encoder}' is not a valid video encoder for this program"
            ;;
    esac
    
    # check if a valid fade effect was entered (-e/--fade)
    case "$fade" in
        in|out|both|none)
            :
            ;;
        *)
            exit_program "'${fade}' is not a valid fade effect"
            ;;
    esac
    
    # check if the entered volume factor is a valid integer/float number (-m)
    if printf '%s' "$volume_factor" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
    then
        # enable volume increase effect if chosen by user
        # (a value different than '1.0' or '0.0')
        if ! { printf '%s' "$volume_factor" | grep -Eq '^[0]+(\.[0]+)?$' ||
               printf '%s' "$volume_factor" | grep -Eq '^[1]+(\.[0]+)?$' ; }
        then
            volume_options="-af volume=${volume_factor}"
        fi
    else
        exit_program "'${volume_factor}' is not a valid number for volume increase effect"
    fi
    
    # do not allow to use -z, -k, -c or -g options without -w option
    if [ "$watermark" = 'false' ] 
    then
        msg='option is to be used only with --watermark (-w) option'
        [ "$wmark_size_setted"   = 'true' ] && exit_program "--wmark-size (-z) ${msg}"
        [ "$wmark_posi_setted"   = 'true' ] && exit_program "--wmark-position (-k) ${msg}"
        [ "$wmark_font_setted"   = 'true' ] && exit_program "--wmark-font (-c) ${msg}"
        [ "$pngoptimizer_setted" = 'true' ] && exit_program "--png-optimizer (-g) ${msg}"
        unset msg
    fi
    
    # check for a valid watermark size format (NxN) (-z/--wmark-size)
    printf '%s' "$watermark_size" | grep -Eq '^[0-9]+x[0-9]+$' || exit_program "'${watermark_size}' is not a valid watermark size format"
    
    # check for a valid watermark position format (N,N) (-k/--wmark-position)
    if printf '%s' "$watermark_position" | grep -Eq '^[0-9]+,[0-9]+$'
    then
        # translate watermark position to what is really used in ffmpeg command
        watermark_position="$(printf "%s" "$watermark_position" | tr ',' ':')"
    else
        exit_program "'${watermark_position}' is not a valid watermark position format"
    fi
    
    # check if the entered fixed video length is a valid integer/float number (-x)
    if printf '%s' "$fixed_length" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
    then
        # enable fixed video length if chosen by user (a value different than '0')
        printf '%s' "$fixed_length" | grep -Eq '^[0]+(\.[0]+)?$' || fixed_length_options="-t ${fixed_length}"
    else
        exit_program "'${fixed_length}' is not a valid number for fixed video length"
    fi
    
    # check for invalid combination of audio encoder and container format
    if {
           [ "$format" = 'mp4' ] && [ "$audio_encoder" = 'opus' ] ;
       } ||
       {
           [ "$format" = 'webm' ] &&
           {
               [ "$audio_encoder" = 'aac'     ] ||
               [ "$audio_encoder" = 'mp3'     ] ||
               [ "$audio_encoder" = 'mp3lame' ] ||
               [ "$audio_encoder" = 'shine'   ] ;
           } ;
       } ||
       {
           [ "$format" = 'ogg' ] &&
           {
               [ "$audio_encoder" = 'aac'     ] ||
               [ "$audio_encoder" = 'mp3'     ] ||
               [ "$audio_encoder" = 'mp3lame' ] ||
               [ "$audio_encoder" = 'shine'   ] ;
           } ;
       }
    then
        msg="container format '${format}' does not support '${audio_encoder}' encoder"
        
        if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
        then
           msg="${msg}
                      (did you forget to select the container format?)"
        fi
        
        show_settings
        exit_program "$msg"
    fi
    
    # check for invalid combination of video encoder and container format
    if {
           [ "$format" = 'mp4' ] &&
           {
               [ "$video_encoder" = 'theora' ] || [ "$video_encoder" = 'vp8' ] ;
           } ;
       } ||
       {
           [ "$format" = 'webm' ] &&
           {
               [ "$video_encoder" = 'x264'       ] ||
               [ "$video_encoder" = 'h264_nvenc' ] ||
               [ "$video_encoder" = 'x265'       ] ||
               [ "$video_encoder" = 'kvazaar'    ] ||
               [ "$video_encoder" = 'hevc_nvenc' ] ||
               [ "$video_encoder" = 'theora'     ] ;
           } ;
       } ||
       {
           [ "$format" = 'ogg' ] &&
           {
               [ "$video_encoder" = 'x264'       ] ||
               [ "$video_encoder" = 'h264_nvenc' ] ||
               [ "$video_encoder" = 'x265'       ] ||
               [ "$video_encoder" = 'kvazaar'    ] ||
               [ "$video_encoder" = 'hevc_nvenc' ] ||
               [ "$video_encoder" = 'vp9'        ] ;
           } ;
       }
    then
        msg="container format '${format}' does not support '${video_encoder}' encoder"
        
        if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
        then
           msg="${msg}
                      (did you forget to select the container format?)"
        fi
        
        show_settings
        exit_program "$msg"
    fi
    
    # special condition check: mp4 + vp9
    # support is enabled only in ffmpeg 3.4 or greater (or git master N-86119-g5ff31babfc or greater)
    if [ "$format" = 'mp4' ] && [ "$video_encoder" = 'vp9' ] 
    then
        ffmpeg_version="$(ffmpeg -version | grep 'Copyright' | cut -d' ' -f3)"
        
        if {
               printf '%s' "$ffmpeg_version" | grep -Eq '^[0-9]+\..*' &&
               ! {
                     [ "$(printf '%s' "$ffmpeg_version" | cut -d'.' -f1)" -ge '3' ] &&
                     [ "$(printf '%s' "$ffmpeg_version" | cut -d'.' -f2)" -ge '4' ] ;
                 } ;
           } ||
           {
               printf '%s' "$ffmpeg_version" | grep -q '^N-.*' &&
               ! [ "$(printf '%s' "$ffmpeg_version" | cut -d'-' -f2)" -ge '86119' ] ;
           }
        then
            msg="support for 'vp9' encoder in 'mp4' container format in your ffmpeg build is experimental
                      it's needed ffmpeg 3.4 or greater (or git master N-86119-g5ff31babfc or greater)"
            
            if [ "$auto_filename" = 'true' ] && [ "$format_setted" = 'false' ] 
            then
                msg="${msg}
                      (did you forget to select the container format?)"
            fi
            
            show_settings
            exit_program "$msg"
        fi
    fi
}

# check_dirs function: check for valid output and tmp directories (-o and -t)
#                      (will exit with error if any problem is encountered)
# arguments: none
# return value: not relevant
# return code (status): not relevant
check_dirs() {
    for directory in "$savedir" "$tmpdir"
    do
        # check if the entered $savedir/$tmpdir already exists and mkdir if not
        if ! [ -e "$directory" ] 
        then
            if ! mkdir -p "$directory"
            then
                case "$directory" in
                    "$savedir")
                        msg='output'
                        ;;
                    "$tmpdir")
                        msg='temporary files'
                        ;;
                esac
                exit_program "failed to create ${msg} directory '${directory}'"
            fi
        fi
        
        # check if the entered $savedir/$tmpdir is a directory
        if [ -d "$directory" ] 
        then
            # check if the entered $savedir/$tmpdir has write permission
            if ! [ -w "$directory" ] 
            then
                case "$directory" in
                    "$savedir")
                        msg='output'
                        ;;
                    "$tmpdir")
                        msg='temporary files'
                        ;;
                esac
                exit_program "no write permission for ${msg} directory '${directory}'"
            fi
        else
            exit_program "'${directory}' is not a directory"
        fi
    done
}

# get_region function: select with mouse the screen region to record
#                      (will exit with error if region selection is canceled)
# arguments: none
# return value: not relevant
# return code (status): not relevant
# note: sets $video_size and $video_position
get_region() {
    print_good 'please select with mouse a screen region to record...'
    print_info 'single click to select a window, click and drag to select a region'
    print_info 'use arrow keys to fine tune when dragging, right click or any other keystroke to cancel'
    
    screen_region="$(slop -o -f '%x %y %w %h')" || exit_program 'screen region was not selected'
    
    if ! printf '%s' "$screen_region" | grep -Eq '^([0-9]+[[:space:]]){3}[0-9]+$'
    then
        exit_program 'slop returned wrong values'
    fi
    
    video_position_x="$(printf '%s' "$screen_region" | cut -d ' ' -f1)"
    video_position_y="$(printf '%s' "$screen_region" | cut -d ' ' -f2)"
    video_width="$(     printf '%s' "$screen_region" | cut -d ' ' -f3)"
    video_height="$(    printf '%s' "$screen_region" | cut -d ' ' -f4)"
    
    # change video width and height if not a multiple of 8
    check_dimension "$video_width"  || adjust_dimension 'width'
    check_dimension "$video_height" || adjust_dimension 'height'
    
    video_size="${video_width}x${video_height}"
    video_position="${video_position_x},${video_position_y}"
}

# randomstr function: generate a random string
# arguments: $1 - desired string length
# return value: a random string
# return code (status): not relevant
randomstr() {
    if [ -c '/dev/urandom' ] 
    then
        rnd="$(LC_CTYPE=C tr -dc '[:alnum:]' < /dev/urandom | head -c"$1")"
    elif command -v shuf >/dev/null 2>&1
    then
        alphanum="a b c d e f g h i j k l m n o p q r s t u v w x y z \
                  A B C D E F G H Y J K L M N O P Q R S T U V W X Y Z \
                  0 1 2 3 4 5 6 7 8 9"
        # redirect stderr to /dev/null to avoid a warning in some bash versions
        { rnd="$(printf '%s' "$(shuf -ez -n"$1" "$alphanum")" )"; } 2>/dev/null
    elif command -v pwgen >/dev/null 2>&1
    then
        rnd="$(pwgen -cns "$1" 1)"
    elif command -v openssl >/dev/null 2>&1
    then
        rnd="$(openssl rand -hex "$1" | cut -c-"$1")"
    else
        rnd="$(awk 'BEGIN{srand(); printf "%d\n",(rand() * 10^8)}')"
        while [ "$(printf "%s" "$rnd" | wc -m)" -lt "$1" ] 
        do
            sleep 1
            rnd="$rnd""$(awk 'BEGIN{srand(); printf "%d\n",(rand() * 10^8)}')"
        done
        rnd="$(printf "%s" "$rnd" | cut -c-"$1")"
    fi
    
    printf '%s' "$rnd"
}

# create_watermark function: create a text watermark and set watermark options
#                            to be passed to ffmpeg command
# arguments: none
# return value: not relevant
# return code (status): 0 - text watermark image was successfully created
#                       1 - failed to create text watermark image
# sets special variables: $watermark_options - ffmpeg watermark options
create_watermark() {
    print_good 'generating watermark image'
    randomstring_png="$(randomstr '20')" # random string for tmp png filename
    wmark_image="${tmpdir}/screencast-tmpimage-${$}-${randomstring_png}.png"
    
    # get font pointsize
    if watermark_pointsize="$(magick \
                                  -size "$watermark_size" \
                                  -font "$watermark_font" \
                                  label:"$watermark_text" \
                                  -format '%[label:pointsize]' \
                                  info:)"
    then
        # check if font pointsize was correctly obtained (integer/float number)
        if printf '%s' "$watermark_pointsize" | grep -Eq '^[0-9]+(\.[0-9]+)?$'
        then
            # generate the watermark
            if magick \
                   -size "$watermark_size" \
                   -font "$watermark_font" \
                   -pointsize "$watermark_pointsize" \
                   -gravity center \
                   \( \
                       xc:grey30 \
                       -draw "fill gray70  text 0,0  '${watermark_text}'" \
                   \) \
                   \( \
                       xc:black \
                       -draw "fill white  text  1,1  '${watermark_text}'  \
                                          text  0,0  '${watermark_text}'  \
                              fill black  text -1,-1 '${watermark_text}'" \
                       -alpha Off \
                   \) \
                   -alpha Off \
                   -compose copy-opacity \
                   -composite \
                   -trim \
                   +repage \
                   "$wmark_image"
            then
                # check if the generated watermark file is truly a PNG image
                if file "$wmark_image" | grep -q 'PNG image data'
                then
                    # optimize PNG image if chosen by user (-g/--png-optimizer)
                    if [ "$pngoptimizer" != 'none' ] 
                    then
                        print_good 'optimizing watermark image'
                        case "$pngoptimizer" in
                            truepng)
                                truepng $truepngsettings "$wmark_image"
                                ;;
                            pingo)
                                pingo $pingosettings "$wmark_image"
                                ;;
                            optipng)
                                optipng $optipngsettings "$wmark_image"
                                ;;
                            opt-png)
                                opt-png "$wmark_image"
                                ;;
                        esac
                        
                        # use advdef to optimize PNG even more
                        advdef $advdefsettings "$wmark_image"
                    fi
                    
                    # set ffmpeg watermark options
                    watermark_input="-framerate ${video_rate} \
                                     -thread_queue_size ${queue_size} \
                                     -i ${wmark_image}"
                    watermark_input="$(remove_spaces "$watermark_input")"
                    watermark_options="overlay=${watermark_position}"
                else
                    print_warn 'the generated watermark is not a PNG file (watermarking aborted)' >&2
                    return 1
                fi # end: if file
            else
                print_warn 'failed to create watermark image (watermarking aborted)' >&2
                return 1
            fi # end: if magick
        else
            print_warn 'the obtained watermark font pointsize is not a valid integer/float number (watermarking aborted)' >&2
            return 1
        fi # end: if printf
    else
        print_warn 'failed to obtain watermark font pointsize (watermarking aborted)' >&2
        return 1
    fi # end: if watermark_pointsize=
}

# video_fade function: sets video fade options to be passed to ffmpeg command
# arguments: none
# return value: none
# return code (status): not relevant
# sets special variables: $fade_options - ffmpeg fade options
videofade() {
    # get recorded video length in seconds
    tmp_1stpart="screencast-tmpvideo-${$}-"  # split large line
    tmp_2ndpart="${randomstring_rec}.${rec_extension}"
    video_length="$(ffprobe \
                        -i "${tmpdir}/${tmp_1stpart}${tmp_2ndpart}" \
                        -show_entries format='duration' \
                        -v quiet \
                        -of csv='p=0')"
    
    # set start time of fade-out in seconds
    total_fadeout="$(printf '%s\n' "${fade_length}  + ${fade_solid_length}" | bc)"
    fadeout_start="$(printf '%s\n' "${video_length} - ${total_fadeout}"     | bc)"
    
    # build ffmpeg fade in/out options
    fadein="fade=type=in:start_time=${fade_solid_length}:duration=${fade_length}:color=${fade_color}"
    fadeout="fade=type=out:start_time=${fadeout_start}:duration=${fade_length}:color=${fade_color}"
    
    # check the chosen fade type and set ffmpeg fade options if necessary
    case "$fade" in
        in)
            fade_options="$fadein"
            ;;
        out)
            fade_options="$fadeout"
            ;;
        both)
            fade_options="${fadein},${fadeout}"
            ;;
    esac
}

#########################################
#            program start              #
#########################################

trap 'cleanup' EXIT HUP INT QUIT ABRT TERM # signal handling

# check for color output support
if command -v tput >/dev/null 2>&1
then
    color_off="$(tput sgr0)"
    color_bold="${color_off}$(tput bold)"
    color_blue="${color_bold}$(tput setaf 4)"
    color_yellow="${color_bold}$(tput setaf 3)"
    color_red="${color_bold}$(tput setaf 1)"
fi

# message header (colored, will fallback to non-colored if no color support)
msg_header="${color_blue:-}[ ${color_bold:-}screencast${color_blue:-} ]"

# enable some options if the executing shell is zsh
if [ -n "$ZSH_VERSION" ] 
then
    command -v setopt >/dev/null 2>&1 || exit_program 'script appears to be running in zsh but setopt was not found'
    setopt SH_WORD_SPLIT # enable variable word splitting
fi

get_cmd_line "$@"
shift "$shift_count" # destroy all arguments except a possible output filename

# check if a X session is running
[ -z "$DISPLAY" ] && exit_program 'it seems that a X session is not running'

check_pngoptimizer
check_requirements

# check if the detected ffmpeg build has support for basic recording formats
ffmpeg_formats="$(ffmpeg -formats -v quiet)"
check_ffmpeg_format 'x11grab' 'X11' || exit 1
if [ "$audio_input" != 'none' ] && [ "$audio_encoder" != 'none' ] 
then
    check_ffmpeg_format 'alsa' 'ALSA audio' || exit 1
    if [ "$audio_input" = 'pulse' ] 
    then
        check_ffmpeg_format 'pulse' 'Pulse audio' || exit 1
    fi
fi

# audio adjustments based on $audio_input value
if [ "$audio_input" = 'none' ] 
then
    # video without audio stream (audio will not be recorded)
    audio_encoder='none' # trigger adjustments during $audio_encoder checks
else
    audio_input="-i ${audio_input}" # add ffmpeg '-i' option
fi

check_cmd_line "$@"
check_dirs
show_settings

# select with mouse the screen region to record if chosen by user
[ "$select_region" = 'true' ] && get_region && check_screen

# some preparations before recording
randomstring_rec="$(randomstr '20')" # random string for tmp video filename
tmpvideo_volatile="${$}-${randomstring_rec}.${rec_extension}"
print_good 'recording'
notify 'normal' '1700' 'media-record' 'recording...'

# record screen to a lossless video
if ffmpeg \
       $audio_general_options \
       $audio_input \
       $video_general_options \
       -framerate $video_rate \
       -video_size $video_size \
       -i :0.0+${video_position} \
       -vf "fps=${video_rate}" \
       $audio_record_codec \
       -vcodec $video_record_codec \
       $fixed_length_options \
       -y \
       "${tmpdir}/screencast-tmpvideo-${tmpvideo_volatile}"
then 
    # enable watermark effect if chosen by user (-w/--watermark)
    if [ "$watermark" = 'true' ] 
    then
        if create_watermark
        then
            vfilter_option='-filter_complex'
            [ "$video_encoder" = 'vp9' ] && pixel_format='yuva420p'
        fi
    fi
    
    # enable fade effect if chosen by user (-e/--fade)
    if [ "$fade" != 'none' ] 
    then
        videofade
        if [ "$watermark" = 'true' ] 
        then
            fade_options=",${fade_options}"
        else
            vfilter_option='-vf'
        fi
    fi
    
    # set output filename
    if [ "$auto_filename" = 'true' ] 
    then
        output_file="screencast-$(date +%Y-%m-%d_%H.%M.%S).${format}"
    else
        output_file="$(basename "$1")"
    fi
    
    print_good 'encoding'
    notify 'normal' '3000' 'media-playback-stop' 'encoding...'
    
    # encode the recorded lossless video file
    if ffmpeg \
           $audio_channel_layout \
           -i "${tmpdir}/screencast-tmpvideo-${tmpvideo_volatile}" \
           $watermark_input \
           $vfilter_option ${watermark_options}${fade_options} \
           $volume_options \
           $audio_encode_codec \
           -vcodec $video_encode_codec \
           -pix_fmt $pixel_format \
           $faststart \
           -map 0 \
           -y \
           "${savedir}/${output_file}"
    then
        print_good 'finish'
        notify 'normal' '3000' 'mail-mark-notjunk' 'finish'
        
        # play a sound after finish if requirements are present
        if command -v paplay >/dev/null 2>&1
        then
            [ -f "$finish_sound" ] && paplay "$finish_sound"
        fi
    else
        print_error 'encoding error!'
        notify 'critical' '5000' 'process-stop' 'encoding error!'
        exit 1
    fi
else
    print_error 'recording error!'
    notify 'critical' '5000' 'process-stop' 'recording error!'
    exit 1
fi
